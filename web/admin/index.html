<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; media-src 'self' blob:; connect-src 'self'; font-src 'self'; form-action 'self'; frame-ancestors 'none';">
    <title>VLog Admin</title>
    <link rel="stylesheet" href="/static/vendor/tailwind.css">
    <script defer src="/static/vendor/alpine.min.js"></script>
    <style>
        [x-cloak] { display: none !important; }
    </style>
</head>
<body class="bg-dark-950 text-dark-100 min-h-screen" x-data="admin()">
    <!-- Header -->
    <header class="bg-dark-900 border-b border-dark-800">
        <div class="max-w-7xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <h1 class="text-2xl font-bold text-white">VLog Admin</h1>
                <div class="flex gap-4">
                    <button
                        @click="tab = 'videos'"
                        :class="tab === 'videos' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Videos</button>
                    <button
                        @click="tab = 'categories'"
                        :class="tab === 'categories' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Categories</button>
                    <button
                        @click="tab = 'upload'"
                        :class="tab === 'upload' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Upload</button>
                    <button
                        @click="tab = 'workers'; loadWorkers()"
                        :class="tab === 'workers' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Workers</button>
                    <button
                        @click="tab = 'analytics'; loadAnalytics()"
                        :class="tab === 'analytics' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Analytics</button>
                </div>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-8">
        <!-- Upload Tab -->
        <div x-show="tab === 'upload'" x-cloak>
            <div class="bg-dark-900 rounded-xl p-6 max-w-2xl mx-auto">
                <h2 class="text-xl font-semibold mb-6">Upload Video</h2>

                <form @submit.prevent="uploadVideo" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium mb-2">Video File</label>
                        <input
                            type="file"
                            accept="video/*"
                            @change="uploadFile = $event.target.files[0]"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                            required
                        >
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Title</label>
                        <input
                            type="text"
                            x-model="uploadTitle"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                            placeholder="Video title"
                            required
                        >
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Description</label>
                        <textarea
                            x-model="uploadDescription"
                            rows="4"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                            placeholder="Video description (optional)"
                        ></textarea>
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Category</label>
                        <select
                            x-model="uploadCategory"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                        >
                            <option value="">No category</option>
                            <template x-for="cat in categories" :key="cat.id">
                                <option :value="cat.id" x-text="cat.name"></option>
                            </template>
                        </select>
                    </div>

                    <!-- Upload Progress -->
                    <div x-show="uploadProgress >= 0" class="space-y-2">
                        <div class="flex justify-between text-sm">
                            <span>Uploading...</span>
                            <span x-text="uploadProgress + '%'"></span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-2">
                            <div
                                class="bg-blue-500 h-2 rounded-full transition-all"
                                :style="'width: ' + uploadProgress + '%'"
                            ></div>
                        </div>
                    </div>

                    <div x-show="uploadMessage" :class="uploadError ? 'text-red-400' : 'text-green-400'" class="text-sm" x-text="uploadMessage"></div>

                    <button
                        type="submit"
                        :disabled="uploading"
                        class="w-full py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!uploading">Upload Video</span>
                        <span x-show="uploading">Uploading...</span>
                    </button>
                </form>
            </div>
        </div>

        <!-- Videos Tab -->
        <div x-show="tab === 'videos'" x-cloak>
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">All Videos</h2>
                <div class="flex gap-4 items-center">
                    <button @click="exportVideos" class="text-green-400 hover:text-green-300">Export</button>
                    <button @click="loadVideos" class="text-blue-400 hover:text-blue-300">Refresh</button>
                </div>
            </div>

            <!-- Bulk Action Toolbar -->
            <div x-show="selectedVideos.length > 0" class="bg-dark-800 rounded-lg p-3 mb-4 flex items-center gap-4">
                <span class="text-dark-300">
                    <span class="font-semibold text-white" x-text="selectedVideos.length"></span> video(s) selected
                </span>
                <div class="flex gap-2 ml-auto">
                    <button
                        @click="openBulkUpdateModal"
                        class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 rounded text-sm font-medium transition"
                    >Update</button>
                    <button
                        @click="openBulkRetranscodeModal"
                        class="px-3 py-1.5 bg-cyan-600 hover:bg-cyan-700 rounded text-sm font-medium transition"
                    >Re-transcode</button>
                    <button
                        @click="bulkRestoreVideos"
                        x-show="selectedVideos.some(id => videos.find(v => v.id === id)?.deleted_at)"
                        class="px-3 py-1.5 bg-green-600 hover:bg-green-700 rounded text-sm font-medium transition"
                    >Restore</button>
                    <button
                        @click="openBulkDeleteModal"
                        class="px-3 py-1.5 bg-red-600 hover:bg-red-700 rounded text-sm font-medium transition"
                    >Delete</button>
                    <button
                        @click="clearSelection"
                        class="px-3 py-1.5 bg-dark-600 hover:bg-dark-500 rounded text-sm font-medium transition"
                    >Clear</button>
                </div>
            </div>

            <div class="bg-dark-900 rounded-xl overflow-hidden">
                <table class="w-full">
                    <thead class="bg-dark-800">
                        <tr>
                            <th class="px-4 py-3 text-left text-sm font-medium w-10">
                                <input
                                    type="checkbox"
                                    :checked="selectedVideos.length === videos.length && videos.length > 0"
                                    @change="toggleSelectAll"
                                    class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"
                                >
                            </th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Thumbnail</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Title</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Category</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Status</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Duration</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Actions</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-dark-800">
                        <template x-for="video in videos" :key="video.id">
                            <tr class="hover:bg-dark-800/50" :class="{'bg-blue-900/20': selectedVideos.includes(video.id)}">
                                <td class="px-4 py-3">
                                    <input
                                        type="checkbox"
                                        :checked="selectedVideos.includes(video.id)"
                                        @change="toggleVideoSelection(video.id)"
                                        class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"
                                    >
                                </td>
                                <td class="px-4 py-3">
                                    <div class="w-24 aspect-video bg-dark-800 rounded overflow-hidden">
                                        <img
                                            :src="video.thumbnail_url"
                                            class="w-full h-full object-cover"
                                            @error="$el.style.display='none'"
                                        >
                                    </div>
                                </td>
                                <td class="px-4 py-3">
                                    <div class="font-medium" x-text="video.title"></div>
                                    <div class="text-dark-500 text-sm" x-text="video.slug"></div>
                                </td>
                                <td class="px-4 py-3 text-dark-400" x-text="video.category_name || '-'"></td>
                                <td class="px-4 py-3">
                                    <div class="space-y-1">
                                        <span
                                            :class="{
                                                'bg-green-500/20 text-green-400': video.status === 'ready',
                                                'bg-yellow-500/20 text-yellow-400': video.status === 'processing',
                                                'bg-blue-500/20 text-blue-400': video.status === 'pending',
                                                'bg-red-500/20 text-red-400': video.status === 'failed'
                                            }"
                                            class="px-2 py-1 rounded text-sm"
                                            x-text="video.status"
                                        ></span>
                                        <span
                                            x-show="video.status === 'ready'"
                                            :class="video.published_at ? 'bg-emerald-500/20 text-emerald-400' : 'bg-dark-600 text-dark-400'"
                                            class="px-2 py-1 rounded text-sm"
                                            x-text="video.published_at ? 'published' : 'draft'"
                                        ></span>
                                        <!-- Progress details for processing videos -->
                                        <template x-if="video.status === 'processing' && progressData[video.id]">
                                            <div class="text-xs space-y-1 mt-2">
                                                <div class="flex items-center gap-2">
                                                    <div class="flex-1 bg-dark-700 rounded-full h-1.5">
                                                        <div
                                                            class="bg-yellow-500 h-1.5 rounded-full transition-all"
                                                            :style="'width: ' + (progressData[video.id]?.progress_percent || 0) + '%'"
                                                        ></div>
                                                    </div>
                                                    <span class="text-dark-400 w-8" x-text="(progressData[video.id]?.progress_percent || 0) + '%'"></span>
                                                </div>
                                                <div class="text-dark-500" x-text="progressData[video.id]?.current_step || ''"></div>
                                                <template x-if="progressData[video.id]?.qualities?.length">
                                                    <div class="flex flex-wrap gap-1 mt-1">
                                                        <template x-for="q in progressData[video.id].qualities" :key="q.name">
                                                            <span
                                                                :class="{
                                                                    'bg-green-500/20 text-green-400': q.status === 'completed' || q.status === 'uploaded',
                                                                    'bg-yellow-500/20 text-yellow-400': q.status === 'in_progress',
                                                                    'bg-dark-700 text-dark-400': q.status === 'pending'
                                                                }"
                                                                class="px-1.5 py-0.5 rounded text-xs"
                                                            >
                                                                <span x-text="q.name"></span>
                                                                <span x-show="q.status === 'in_progress'" x-text="' ' + q.progress + '%'"></span>
                                                            </span>
                                                        </template>
                                                    </div>
                                                </template>
                                            </div>
                                        </template>
                                        <!-- Pending indicator -->
                                        <template x-if="video.status === 'pending'">
                                            <div class="text-xs text-dark-500 mt-1">Waiting for worker...</div>
                                        </template>
                                        <!-- Error message for failed -->
                                        <template x-if="video.status === 'failed' && progressData[video.id]?.last_error">
                                            <div class="text-xs text-red-400 mt-1 max-w-xs truncate" x-text="progressData[video.id].last_error"></div>
                                        </template>
                                    </div>
                                </td>
                                <td class="px-4 py-3 text-dark-400" x-text="formatDuration(video.duration)"></td>
                                <td class="px-4 py-3">
                                    <div class="flex gap-2 flex-wrap">
                                        <button
                                            @click="openEditModal(video)"
                                            class="text-blue-400 hover:text-blue-300 text-sm"
                                        >Edit</button>
                                        <button
                                            x-show="video.status !== 'processing'"
                                            @click="openReuploadModal(video)"
                                            class="text-purple-400 hover:text-purple-300 text-sm"
                                        >Re-upload</button>
                                        <!-- Re-transcode dropdown -->
                                        <div class="relative" x-data="{ open: false }">
                                            <button
                                                @click="open = !open"
                                                @click.away="open = false"
                                                class="text-cyan-400 hover:text-cyan-300 text-sm"
                                            >Re-transcode</button>
                                            <div
                                                x-show="open"
                                                x-cloak
                                                class="absolute left-0 mt-1 w-36 bg-dark-800 border border-dark-700 rounded-lg shadow-lg z-10"
                                            >
                                                <button
                                                    @click="retranscodeAll(video); open = false"
                                                    class="w-full text-left px-3 py-2 text-sm hover:bg-dark-700 rounded-t-lg"
                                                >All Qualities</button>
                                                <button
                                                    @click="openRetranscodeModal(video); open = false"
                                                    class="w-full text-left px-3 py-2 text-sm hover:bg-dark-700 rounded-b-lg"
                                                >Select Qualities...</button>
                                            </div>
                                        </div>
                                        <button
                                            x-show="video.status === 'failed'"
                                            @click="retryVideo(video.id)"
                                            class="text-yellow-400 hover:text-yellow-300 text-sm"
                                        >Retry</button>
                                        <button
                                            x-show="video.status === 'ready'"
                                            @click="togglePublish(video)"
                                            :class="video.published_at ? 'text-orange-400 hover:text-orange-300' : 'text-emerald-400 hover:text-emerald-300'"
                                            class="text-sm"
                                            x-text="video.published_at ? 'Unpublish' : 'Publish'"
                                        ></button>
                                        <button
                                            x-show="video.status === 'ready'"
                                            @click="openThumbnailModal(video)"
                                            class="text-green-400 hover:text-green-300 text-sm"
                                        >Thumbnail</button>
                                        <button
                                            @click="deleteVideo(video.id)"
                                            class="text-red-400 hover:text-red-300 text-sm"
                                        >Delete</button>
                                    </div>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>

                <div x-show="videos.length === 0" class="text-center py-8 text-dark-400">
                    No videos yet. Upload your first video!
                </div>
            </div>
        </div>

        <!-- Categories Tab -->
        <div x-show="tab === 'categories'" x-cloak>
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">Categories</h2>
            </div>

            <div class="grid md:grid-cols-2 gap-6">
                <!-- Add Category -->
                <div class="bg-dark-900 rounded-xl p-6">
                    <h3 class="font-medium mb-4">Add Category</h3>
                    <form @submit.prevent="createCategory" class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">Name</label>
                            <input
                                type="text"
                                x-model="newCategoryName"
                                class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                placeholder="Category name"
                                required
                            >
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Description</label>
                            <textarea
                                x-model="newCategoryDesc"
                                rows="2"
                                class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                placeholder="Optional description"
                            ></textarea>
                        </div>
                        <button
                            type="submit"
                            class="w-full py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition"
                        >Add Category</button>
                    </form>
                </div>

                <!-- Category List -->
                <div class="bg-dark-900 rounded-xl p-6">
                    <h3 class="font-medium mb-4">Existing Categories</h3>
                    <div class="space-y-2">
                        <template x-for="cat in categories" :key="cat.id">
                            <div class="flex justify-between items-center p-3 bg-dark-800 rounded-lg">
                                <div>
                                    <div class="font-medium" x-text="cat.name"></div>
                                    <div class="text-dark-500 text-sm" x-text="cat.video_count + ' videos'"></div>
                                </div>
                                <button
                                    @click="deleteCategory(cat.id)"
                                    class="text-red-400 hover:text-red-300 text-sm"
                                >Delete</button>
                            </div>
                        </template>
                        <div x-show="categories.length === 0" class="text-dark-400 text-center py-4">
                            No categories yet.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div x-show="tab === 'analytics'" x-cloak>
            <!-- Overview Cards -->
            <div class="grid grid-cols-3 gap-4 mb-8">
                <div class="bg-dark-900 rounded-xl p-6">
                    <div class="text-dark-400 text-sm mb-1">Total Views</div>
                    <div class="text-2xl font-bold" x-text="analyticsOverview.total_views?.toLocaleString() || '0'"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-6">
                    <div class="text-dark-400 text-sm mb-1">Watch Time</div>
                    <div class="text-2xl font-bold" x-text="formatHours(analyticsOverview.total_watch_time_hours)"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-6">
                    <div class="text-dark-400 text-sm mb-1">Completion Rate</div>
                    <div class="text-2xl font-bold" x-text="formatPercent(analyticsOverview.completion_rate)"></div>
                </div>
            </div>

            <!-- Period Stats -->
            <div class="grid grid-cols-3 gap-4 mb-8">
                <div class="bg-dark-800 rounded-lg p-4 text-center">
                    <div class="text-dark-400 text-xs uppercase mb-1">Today</div>
                    <div class="text-lg font-semibold" x-text="analyticsOverview.views_today || 0"></div>
                </div>
                <div class="bg-dark-800 rounded-lg p-4 text-center">
                    <div class="text-dark-400 text-xs uppercase mb-1">This Week</div>
                    <div class="text-lg font-semibold" x-text="analyticsOverview.views_this_week || 0"></div>
                </div>
                <div class="bg-dark-800 rounded-lg p-4 text-center">
                    <div class="text-dark-400 text-xs uppercase mb-1">This Month</div>
                    <div class="text-lg font-semibold" x-text="analyticsOverview.views_this_month || 0"></div>
                </div>
            </div>

            <!-- Top Videos Table -->
            <div class="bg-dark-900 rounded-xl overflow-hidden">
                <div class="px-6 py-4 border-b border-dark-800 flex justify-between items-center">
                    <h3 class="font-semibold">Top Videos</h3>
                    <select x-model="analyticsPeriod" @change="loadVideoAnalytics" class="bg-dark-800 border border-dark-700 rounded px-3 py-1 text-sm">
                        <option value="all">All Time</option>
                        <option value="month">This Month</option>
                        <option value="week">This Week</option>
                        <option value="day">Today</option>
                    </select>
                </div>
                <table class="w-full">
                    <thead class="bg-dark-800">
                        <tr>
                            <th class="px-4 py-3 text-left text-sm font-medium">Video</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Views</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Watch Time</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Avg Duration</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Completion</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-dark-800">
                        <template x-for="video in analyticsVideos" :key="video.video_id">
                            <tr class="hover:bg-dark-800/50">
                                <td class="px-4 py-3">
                                    <div class="flex items-center gap-3">
                                        <div class="w-16 aspect-video bg-dark-800 rounded overflow-hidden flex-shrink-0">
                                            <img :src="video.thumbnail_url" class="w-full h-full object-cover" @error="$el.style.display='none'">
                                        </div>
                                        <div class="font-medium truncate max-w-xs" x-text="video.title"></div>
                                    </div>
                                </td>
                                <td class="px-4 py-3 text-right" x-text="video.total_views.toLocaleString()"></td>
                                <td class="px-4 py-3 text-right text-dark-400" x-text="formatWatchTime(video.total_watch_time_seconds)"></td>
                                <td class="px-4 py-3 text-right text-dark-400" x-text="formatDuration(video.avg_watch_duration_seconds)"></td>
                                <td class="px-4 py-3 text-right" x-text="formatPercent(video.completion_rate)"></td>
                            </tr>
                        </template>
                    </tbody>
                </table>
                <div x-show="analyticsVideos.length === 0" class="text-center py-8 text-dark-400">
                    No playback data yet. Views will appear here once videos are watched.
                </div>
            </div>
        </div>

        <!-- Workers Tab -->
        <div x-show="tab === 'workers'" x-cloak>
            <!-- Worker Status Summary -->
            <div class="grid grid-cols-5 gap-4 mb-6">
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-dark-400 text-sm mb-1">Total</div>
                    <div class="text-2xl font-bold" x-text="workerStats.total_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-green-400 text-sm mb-1">Active</div>
                    <div class="text-2xl font-bold text-green-400" x-text="workerStats.active_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-blue-400 text-sm mb-1">Idle</div>
                    <div class="text-2xl font-bold text-blue-400" x-text="workerStats.idle_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-red-400 text-sm mb-1">Offline</div>
                    <div class="text-2xl font-bold text-red-400" x-text="workerStats.offline_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-dark-500 text-sm mb-1">Disabled</div>
                    <div class="text-2xl font-bold text-dark-500" x-text="workerStats.disabled_count || 0"></div>
                </div>
            </div>

            <!-- Workers List -->
            <div class="bg-dark-900 rounded-xl overflow-hidden mb-6">
                <div class="px-6 py-4 border-b border-dark-800 flex justify-between items-center">
                    <h3 class="font-semibold">Workers</h3>
                    <button @click="loadWorkers" class="text-blue-400 hover:text-blue-300 text-sm">Refresh</button>
                </div>

                <div class="divide-y divide-dark-800">
                    <template x-for="worker in workersList" :key="worker.id">
                        <div class="p-4 hover:bg-dark-800/50">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center gap-3">
                                    <!-- Status indicator -->
                                    <div
                                        :class="{
                                            'bg-green-500': worker.status === 'active',
                                            'bg-blue-500': worker.status === 'idle',
                                            'bg-red-500': worker.status === 'offline',
                                            'bg-dark-600': worker.status === 'disabled'
                                        }"
                                        class="w-3 h-3 rounded-full"
                                    ></div>
                                    <div>
                                        <div class="font-medium" x-text="worker.worker_name || worker.worker_id.slice(0, 8)"></div>
                                        <div class="text-dark-500 text-sm flex items-center gap-2">
                                            <span :class="{
                                                'text-green-400': worker.status === 'active',
                                                'text-blue-400': worker.status === 'idle',
                                                'text-red-400': worker.status === 'offline',
                                                'text-dark-500': worker.status === 'disabled'
                                            }" x-text="worker.status.charAt(0).toUpperCase() + worker.status.slice(1)"></span>
                                            <span class="text-dark-600">•</span>
                                            <span x-text="worker.hwaccel_type ? (worker.gpu_name || worker.hwaccel_type.toUpperCase()) : 'CPU'"></span>
                                            <template x-if="worker.seconds_since_heartbeat !== null">
                                                <span class="text-dark-600">•</span>
                                            </template>
                                            <template x-if="worker.seconds_since_heartbeat !== null">
                                                <span
                                                    :class="{
                                                        'text-green-400': worker.seconds_since_heartbeat < 30,
                                                        'text-yellow-400': worker.seconds_since_heartbeat >= 30 && worker.seconds_since_heartbeat < 120,
                                                        'text-red-400': worker.seconds_since_heartbeat >= 120
                                                    }"
                                                    x-text="formatTimeSince(worker.seconds_since_heartbeat)"
                                                ></span>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center gap-4">
                                    <!-- Stats -->
                                    <div class="text-right text-sm">
                                        <div class="text-dark-400">
                                            <span class="text-green-400" x-text="worker.jobs_completed"></span> completed
                                            <template x-if="worker.jobs_failed > 0">
                                                <span>, <span class="text-red-400" x-text="worker.jobs_failed"></span> failed</span>
                                            </template>
                                        </div>
                                    </div>
                                    <!-- Actions -->
                                    <div class="flex gap-2">
                                        <button
                                            x-show="worker.status !== 'disabled'"
                                            @click="disableWorker(worker.worker_id)"
                                            class="text-yellow-400 hover:text-yellow-300 text-sm"
                                        >Disable</button>
                                        <button
                                            x-show="worker.status === 'disabled'"
                                            @click="enableWorker(worker.worker_id)"
                                            class="text-green-400 hover:text-green-300 text-sm"
                                        >Enable</button>
                                        <button
                                            @click="deleteWorker(worker.worker_id, worker.worker_name)"
                                            class="text-red-400 hover:text-red-300 text-sm"
                                        >Delete</button>
                                    </div>
                                </div>
                            </div>
                            <!-- Current job info -->
                            <template x-if="worker.current_video_title">
                                <div class="mt-2 ml-6 text-sm">
                                    <div class="flex items-center gap-2">
                                        <span class="text-dark-400">Processing:</span>
                                        <span class="text-white" x-text="worker.current_video_title"></span>
                                        <span class="text-dark-500" x-text="'(' + worker.current_step + ')'"></span>
                                    </div>
                                    <div class="flex items-center gap-2 mt-1">
                                        <div class="flex-1 max-w-xs bg-dark-700 rounded-full h-1.5">
                                            <div
                                                class="bg-green-500 h-1.5 rounded-full transition-all"
                                                :style="'width: ' + (worker.current_progress || 0) + '%'"
                                            ></div>
                                        </div>
                                        <span class="text-dark-400 text-xs" x-text="(worker.current_progress || 0) + '%'"></span>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>

                <div x-show="workersList.length === 0" class="text-center py-8 text-dark-400">
                    No workers registered. Use <code class="bg-dark-800 px-2 py-1 rounded">vlog worker register</code> to add workers.
                </div>
            </div>

            <!-- Active Jobs -->
            <div class="bg-dark-900 rounded-xl overflow-hidden">
                <div class="px-6 py-4 border-b border-dark-800 flex justify-between items-center">
                    <h3 class="font-semibold">
                        Active Transcoding Jobs
                        <span class="text-dark-500 font-normal" x-text="'(' + (activeJobs.processing_count || 0) + ' processing, ' + (activeJobs.pending_count || 0) + ' pending)'"></span>
                    </h3>
                </div>

                <div class="divide-y divide-dark-800">
                    <template x-for="job in activeJobs.jobs" :key="job.job_id">
                        <div class="p-4">
                            <div class="flex items-start gap-4">
                                <!-- Video info -->
                                <div class="flex-1">
                                    <div class="font-medium" x-text="job.video_title"></div>
                                    <div class="text-dark-500 text-sm flex items-center gap-2 mt-1">
                                        <template x-if="job.worker_name">
                                            <span>
                                                Worker: <span class="text-white" x-text="job.worker_name"></span>
                                                <span x-show="job.worker_hwaccel_type" class="text-dark-400" x-text="'(' + job.worker_hwaccel_type + ')'"></span>
                                            </span>
                                        </template>
                                        <template x-if="!job.worker_name && job.status === 'pending'">
                                            <span class="text-blue-400">Waiting for worker...</span>
                                        </template>
                                    </div>
                                </div>
                                <!-- Progress -->
                                <div class="w-48">
                                    <div class="flex items-center justify-between text-sm mb-1">
                                        <span
                                            :class="{
                                                'text-yellow-400': job.status === 'processing',
                                                'text-blue-400': job.status === 'pending'
                                            }"
                                            x-text="job.current_step || job.status"
                                        ></span>
                                        <span class="text-dark-400" x-text="job.progress_percent + '%'"></span>
                                    </div>
                                    <div class="w-full bg-dark-700 rounded-full h-2">
                                        <div
                                            :class="{
                                                'bg-yellow-500': job.status === 'processing',
                                                'bg-blue-500': job.status === 'pending'
                                            }"
                                            class="h-2 rounded-full transition-all"
                                            :style="'width: ' + job.progress_percent + '%'"
                                        ></div>
                                    </div>
                                    <!-- Quality badges -->
                                    <template x-if="job.qualities && job.qualities.length > 0">
                                        <div class="flex flex-wrap gap-1 mt-2">
                                            <template x-for="q in job.qualities" :key="q.name">
                                                <span
                                                    :class="{
                                                        'bg-green-500/20 text-green-400': q.status === 'completed' || q.status === 'uploaded',
                                                        'bg-yellow-500/20 text-yellow-400': q.status === 'in_progress',
                                                        'bg-dark-700 text-dark-400': q.status === 'pending'
                                                    }"
                                                    class="px-1.5 py-0.5 rounded text-xs"
                                                >
                                                    <span x-text="q.name"></span>
                                                    <span x-show="q.status === 'in_progress'" x-text="' ' + q.progress + '%'"></span>
                                                </span>
                                            </template>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>

                <div x-show="!activeJobs.jobs || activeJobs.jobs.length === 0" class="text-center py-8 text-dark-400">
                    No active transcoding jobs.
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Video Modal -->
    <div x-show="editModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="editModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-semibold mb-4">Edit Video</h3>
            <form @submit.prevent="saveVideo" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Title</label>
                    <input
                        type="text"
                        x-model="editTitle"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                        required
                    >
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Description</label>
                    <textarea
                        x-model="editDescription"
                        rows="4"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    ></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Category</label>
                    <select
                        x-model="editCategory"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                        <option value="0">No category</option>
                        <template x-for="cat in categories" :key="cat.id">
                            <option :value="cat.id" x-text="cat.name"></option>
                        </template>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Publish Date</label>
                    <input
                        type="datetime-local"
                        x-model="editPublishedAt"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                    <p class="text-xs text-gray-500 mt-1">Leave empty to use current date when video becomes ready</p>
                </div>
                <div class="flex gap-3 pt-2">
                    <button
                        type="button"
                        @click="editModal = false"
                        class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 rounded-lg font-medium transition"
                    >Cancel</button>
                    <button
                        type="submit"
                        class="flex-1 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition"
                    >Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Re-upload Video Modal -->
    <div x-show="reuploadModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="reuploadModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-semibold mb-2">Re-upload Video</h3>
            <p class="text-dark-400 text-sm mb-4">
                Replace the video file for "<span x-text="reuploadTitle" class="text-white"></span>".
                This will delete all transcoded files and re-process the video.
                Metadata (title, description, category, dates) will be preserved.
            </p>
            <form @submit.prevent="reuploadVideo" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">New Video File</label>
                    <input
                        type="file"
                        accept="video/*"
                        @change="reuploadFile = $event.target.files[0]"
                        class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-purple-500"
                        required
                    >
                </div>

                <!-- Re-upload Progress -->
                <div x-show="reuploadProgress >= 0" class="space-y-2">
                    <div class="flex justify-between text-sm">
                        <span>Uploading...</span>
                        <span x-text="reuploadProgress + '%'"></span>
                    </div>
                    <div class="w-full bg-dark-700 rounded-full h-2">
                        <div
                            class="bg-purple-500 h-2 rounded-full transition-all"
                            :style="'width: ' + reuploadProgress + '%'"
                        ></div>
                    </div>
                </div>

                <div x-show="reuploadMessage" :class="reuploadError ? 'text-red-400' : 'text-green-400'" class="text-sm" x-text="reuploadMessage"></div>

                <div class="flex gap-3 pt-2">
                    <button
                        type="button"
                        @click="reuploadModal = false"
                        :disabled="reuploading"
                        class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                    >Cancel</button>
                    <button
                        type="submit"
                        :disabled="reuploading"
                        class="flex-1 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!reuploading">Re-upload</span>
                        <span x-show="reuploading">Uploading...</span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Re-transcode Video Modal -->
    <div x-show="retranscodeModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="retranscodeModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-semibold mb-2">Re-transcode Video</h3>
            <p class="text-dark-400 text-sm mb-4">
                Select qualities to re-transcode for "<span x-text="retranscodeTitle" class="text-white"></span>".
                Selected quality files will be deleted and regenerated from the source.
            </p>

            <div class="space-y-4">
                <!-- Select All / Deselect All buttons -->
                <div class="flex gap-2">
                    <button
                        @click="selectAllQualities"
                        class="px-3 py-1 text-sm bg-dark-700 hover:bg-dark-600 rounded transition"
                    >Select All</button>
                    <button
                        @click="deselectAllQualities"
                        class="px-3 py-1 text-sm bg-dark-700 hover:bg-dark-600 rounded transition"
                    >Deselect All</button>
                </div>

                <!-- Quality checkboxes -->
                <div class="space-y-2 max-h-64 overflow-y-auto">
                    <template x-for="quality in retranscodeAvailable" :key="quality">
                        <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                            <input
                                type="checkbox"
                                :checked="retranscodeSelected.includes(quality)"
                                @change="toggleRetranscodeQuality(quality)"
                                class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                            >
                            <span class="flex-1">
                                <span class="font-medium" x-text="quality"></span>
                            </span>
                            <span
                                :class="{
                                    'text-green-400': getQualityStatus(quality) === 'completed',
                                    'text-dark-500': getQualityStatus(quality) === 'not transcoded'
                                }"
                                class="text-xs"
                                x-text="getQualityStatus(quality)"
                            ></span>
                        </label>
                    </template>
                </div>

                <!-- No qualities message -->
                <div x-show="retranscodeAvailable.length === 0" class="text-dark-400 text-center py-4">
                    No qualities available for this video.
                </div>

                <!-- Status message -->
                <div x-show="retranscodeMessage" :class="retranscodeError ? 'text-red-400' : 'text-green-400'" class="text-sm" x-text="retranscodeMessage"></div>

                <!-- Action buttons -->
                <div class="flex gap-3 pt-2">
                    <button
                        type="button"
                        @click="retranscodeModal = false"
                        :disabled="retranscoding"
                        class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                    >Cancel</button>
                    <button
                        @click="submitRetranscode()"
                        :disabled="retranscoding || retranscodeSelected.length === 0"
                        class="flex-1 py-2 bg-cyan-600 hover:bg-cyan-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!retranscoding">Re-transcode (<span x-text="retranscodeSelected.length"></span>)</span>
                        <span x-show="retranscoding">Processing...</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Thumbnail Selection Modal -->
    <div x-show="thumbnailModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="thumbnailModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-3xl mx-4 max-h-[90vh] overflow-y-auto">
            <h3 class="text-xl font-semibold mb-2">Select Thumbnail</h3>
            <p class="text-dark-400 text-sm mb-4">
                Choose a thumbnail for "<span x-text="thumbnailVideoTitle" class="text-white"></span>"
            </p>

            <!-- Current Thumbnail -->
            <div class="mb-6">
                <h4 class="text-sm font-medium mb-2 text-dark-300">Current Thumbnail</h4>
                <div class="flex items-center gap-4">
                    <div class="w-40 aspect-video bg-dark-800 rounded overflow-hidden">
                        <img :src="'/videos/' + thumbnailVideoSlug + '/thumbnail.jpg?t=' + Date.now()"
                             class="w-full h-full object-cover"
                             @error="$el.style.display='none'">
                    </div>
                    <div class="text-sm text-dark-400">
                        <span>Source:</span>
                        <span class="text-white capitalize" x-text="thumbnailSource"></span>
                    </div>
                </div>
            </div>

            <!-- Frame Selection -->
            <div class="mb-6">
                <div class="flex justify-between items-center mb-3">
                    <h4 class="text-sm font-medium text-dark-300">Select from Video Frames</h4>
                    <button
                        @click="generateThumbnailFrames()"
                        :disabled="thumbnailLoading"
                        class="px-3 py-1 text-sm bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded transition"
                    >
                        <span x-show="!thumbnailLoading">Generate Frames</span>
                        <span x-show="thumbnailLoading">Generating...</span>
                    </button>
                </div>
                <div x-show="thumbnailFrames.length > 0" class="grid grid-cols-5 gap-2">
                    <template x-for="frame in thumbnailFrames" :key="frame.index">
                        <button
                            @click="selectThumbnailFrame(frame.timestamp)"
                            :disabled="thumbnailLoading"
                            class="aspect-video bg-dark-800 rounded overflow-hidden hover:ring-2 hover:ring-cyan-500 transition relative group"
                        >
                            <img :src="frame.url + '?t=' + Date.now()" class="w-full h-full object-cover">
                            <div class="absolute bottom-0 left-0 right-0 bg-black/70 text-xs text-center py-1" x-text="formatDuration(frame.timestamp)"></div>
                        </button>
                    </template>
                </div>
                <div x-show="thumbnailFrames.length === 0" class="text-dark-500 text-sm py-4 text-center bg-dark-800 rounded">
                    Click "Generate Frames" to see frame options from the video.
                </div>
            </div>

            <!-- Custom Upload -->
            <div class="mb-6">
                <h4 class="text-sm font-medium mb-2 text-dark-300">Upload Custom Thumbnail</h4>
                <div class="flex items-center gap-3">
                    <input
                        type="file"
                        accept="image/jpeg,image/png,image/webp"
                        @change="thumbnailUploadFile = $event.target.files[0]"
                        class="flex-1 px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg text-sm file:mr-3 file:py-1 file:px-3 file:rounded file:border-0 file:bg-dark-700 file:text-white"
                    >
                    <button
                        @click="uploadCustomThumbnail()"
                        :disabled="!thumbnailUploadFile || thumbnailUploading"
                        class="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 disabled:bg-dark-700 disabled:opacity-50 rounded-lg text-sm font-medium transition"
                    >
                        <span x-show="!thumbnailUploading">Upload</span>
                        <span x-show="thumbnailUploading">Uploading...</span>
                    </button>
                </div>
                <p class="text-xs text-dark-500 mt-2">Accepts JPEG, PNG, or WebP (max 10MB). Will be resized to 640px width.</p>
            </div>

            <!-- Revert Option -->
            <div class="mb-6" x-show="thumbnailSource !== 'auto'">
                <button
                    @click="revertThumbnail()"
                    :disabled="thumbnailLoading"
                    class="text-sm text-yellow-400 hover:text-yellow-300 disabled:opacity-50"
                >Revert to auto-generated thumbnail</button>
            </div>

            <!-- Messages -->
            <div x-show="thumbnailMessage" :class="thumbnailError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="thumbnailMessage"></div>

            <!-- Close Button -->
            <div class="flex justify-end">
                <button
                    @click="thumbnailModal = false"
                    class="px-4 py-2 bg-dark-700 hover:bg-dark-600 rounded-lg font-medium transition"
                >Close</button>
            </div>
        </div>
    </div>

    <!-- Bulk Delete Modal -->
    <div x-show="bulkDeleteModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="bulkDeleteModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-semibold mb-4">Delete Videos</h3>
            <p class="text-dark-300 mb-4">
                You are about to delete <span class="text-white font-semibold" x-text="selectedVideos.length"></span> video(s).
            </p>
            <div class="mb-4">
                <label class="flex items-center gap-3 cursor-pointer">
                    <input
                        type="checkbox"
                        x-model="bulkDeletePermanent"
                        class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-red-500 focus:ring-red-500 focus:ring-offset-0"
                    >
                    <span class="text-dark-300">Permanently delete (cannot be undone)</span>
                </label>
            </div>
            <div x-show="bulkOpMessage" :class="bulkOpError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="bulkOpMessage"></div>
            <div class="flex gap-3">
                <button
                    @click="bulkDeleteModal = false"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                >Cancel</button>
                <button
                    @click="executeBulkDelete"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-red-600 hover:bg-red-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                >
                    <span x-show="!bulkOpLoading">Delete</span>
                    <span x-show="bulkOpLoading">Deleting...</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Bulk Update Modal -->
    <div x-show="bulkUpdateModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="bulkUpdateModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-semibold mb-4">Update Videos</h3>
            <p class="text-dark-300 mb-4">
                Update <span class="text-white font-semibold" x-text="selectedVideos.length"></span> video(s) with the following settings:
            </p>
            <div class="space-y-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Category</label>
                    <select
                        x-model="bulkUpdateCategory"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                        <option value="">-- Don't change --</option>
                        <option value="0">Remove category</option>
                        <template x-for="cat in categories" :key="cat.id">
                            <option :value="cat.id" x-text="cat.name"></option>
                        </template>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Published Date</label>
                    <input
                        type="datetime-local"
                        x-model="bulkUpdatePublishedAt"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                    <div class="mt-2">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input
                                type="checkbox"
                                x-model="bulkUpdateUnpublish"
                                class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"
                            >
                            <span class="text-dark-400 text-sm">Unpublish (remove published date)</span>
                        </label>
                    </div>
                </div>
            </div>
            <div x-show="bulkOpMessage" :class="bulkOpError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="bulkOpMessage"></div>
            <div class="flex gap-3">
                <button
                    @click="bulkUpdateModal = false"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                >Cancel</button>
                <button
                    @click="executeBulkUpdate"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                >
                    <span x-show="!bulkOpLoading">Update</span>
                    <span x-show="bulkOpLoading">Updating...</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Bulk Retranscode Modal -->
    <div x-show="bulkRetranscodeModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="bulkRetranscodeModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-semibold mb-4">Re-transcode Videos</h3>
            <p class="text-dark-300 mb-4">
                Queue <span class="text-white font-semibold" x-text="selectedVideos.length"></span> video(s) for re-transcoding.
            </p>
            <div class="space-y-2 mb-4">
                <label class="block text-sm font-medium mb-2">Qualities to re-transcode</label>
                <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                    <input
                        type="radio"
                        name="bulkRetranscodeQuality"
                        value="all"
                        x-model="bulkRetranscodeQuality"
                        class="w-4 h-4 border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                    >
                    <span>All qualities (full re-encode)</span>
                </label>
                <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                    <input
                        type="radio"
                        name="bulkRetranscodeQuality"
                        value="1080p"
                        x-model="bulkRetranscodeQuality"
                        class="w-4 h-4 border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                    >
                    <span>1080p only</span>
                </label>
                <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                    <input
                        type="radio"
                        name="bulkRetranscodeQuality"
                        value="720p"
                        x-model="bulkRetranscodeQuality"
                        class="w-4 h-4 border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                    >
                    <span>720p only</span>
                </label>
            </div>
            <div x-show="bulkOpMessage" :class="bulkOpError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="bulkOpMessage"></div>
            <div class="flex gap-3">
                <button
                    @click="bulkRetranscodeModal = false"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                >Cancel</button>
                <button
                    @click="executeBulkRetranscode"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-cyan-600 hover:bg-cyan-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                >
                    <span x-show="!bulkOpLoading">Re-transcode</span>
                    <span x-show="bulkOpLoading">Queueing...</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div x-show="showAuthModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center bg-black/70">
        <div class="bg-dark-900 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl">
            <h3 class="text-xl font-semibold mb-4">Authentication Required</h3>
            <p class="text-dark-400 mb-4">This Admin API requires authentication. Enter your admin secret to continue.</p>
            <form @submit.prevent="submitAuth">
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Admin Secret</label>
                    <input
                        type="password"
                        x-model="authSecretInput"
                        x-ref="authInput"
                        class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                        placeholder="Enter VLOG_ADMIN_API_SECRET"
                        required
                        autocomplete="new-password"
                    >
                </div>
                <div x-show="authError" class="text-red-400 text-sm mb-4" x-text="authError"></div>
                <div class="flex gap-3">
                    <button
                        type="submit"
                        :disabled="authLoading"
                        class="flex-1 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!authLoading">Authenticate</span>
                        <span x-show="authLoading">Checking...</span>
                    </button>
                </div>
            </form>
            <p class="text-dark-500 text-xs mt-4 text-center">Secret is stored for this browser session (cleared when you close this tab)</p>
        </div>
    </div>

    <script>
        function admin() {
            return {
                // Authentication state
                adminSecret: sessionStorage.getItem('adminSecret') || '',
                showAuthModal: false,
                authSecretInput: '',
                authError: '',
                authLoading: false,
                authRequired: false,

                tab: 'videos',
                videos: [],
                categories: [],

                // Upload form
                uploadFile: null,
                uploadTitle: '',
                uploadDescription: '',
                uploadCategory: '',
                uploading: false,
                uploadProgress: -1,
                uploadMessage: '',
                uploadError: false,

                // Category form
                newCategoryName: '',
                newCategoryDesc: '',

                // Edit modal
                editModal: false,
                editVideoId: null,
                editTitle: '',
                editDescription: '',
                editCategory: 0,
                editPublishedAt: '',

                // Re-upload modal
                reuploadModal: false,
                reuploadVideoId: null,
                reuploadTitle: '',
                reuploadFile: null,
                reuploading: false,
                reuploadProgress: -1,
                reuploadMessage: '',
                reuploadError: false,

                // Re-transcode modal
                retranscodeModal: false,
                retranscodeVideoId: null,
                retranscodeTitle: '',
                retranscodeQualities: [],
                retranscodeAvailable: [],
                retranscodeExisting: [],
                retranscodeSelected: [],
                retranscoding: false,
                retranscodeMessage: '',
                retranscodeError: false,

                // Thumbnail selection modal
                thumbnailModal: false,
                thumbnailVideoId: null,
                thumbnailVideoSlug: '',
                thumbnailVideoTitle: '',
                thumbnailDuration: 0,
                thumbnailSource: 'auto',
                thumbnailFrames: [],
                thumbnailLoading: false,
                thumbnailUploading: false,
                thumbnailUploadFile: null,
                thumbnailMessage: '',
                thumbnailError: false,

                // Analytics
                analyticsOverview: {},
                analyticsVideos: [],
                analyticsPeriod: 'all',

                // Workers
                workersList: [],
                workerStats: {},
                activeJobs: { jobs: [], total_count: 0, processing_count: 0, pending_count: 0 },

                // Transcode progress
                progressData: {},

                // SSE connections for real-time updates
                progressSSE: null,
                workersSSE: null,
                sseReconnectAttempts: 0,
                maxSseReconnectDelay: 30000,

                // Bulk operations
                selectedVideos: [],
                bulkDeleteModal: false,
                bulkDeletePermanent: false,
                bulkUpdateModal: false,
                bulkUpdateCategory: '',
                bulkUpdatePublishedAt: '',
                bulkUpdateUnpublish: false,
                bulkRetranscodeModal: false,
                bulkRetranscodeQuality: 'all',
                bulkOpLoading: false,
                bulkOpMessage: '',
                bulkOpError: false,

                // Helper function to make authenticated API requests
                async apiFetch(url, options = {}) {
                    // Create a new headers object to avoid mutating the caller's object
                    const headers = { ...(options.headers || {}) };
                    if (this.adminSecret) {
                        headers['X-Admin-Secret'] = this.adminSecret;
                    }
                    const response = await fetch(url, { ...options, headers });

                    // Handle auth errors
                    if (response.status === 401 || response.status === 403) {
                        this.authRequired = true;
                        this.showAuthModal = true;
                        this.adminSecret = '';
                        sessionStorage.removeItem('adminSecret');
                        throw new Error('Authentication required');
                    }

                    return response;
                },

                // Submit authentication
                async submitAuth() {
                    this.authError = '';
                    this.authLoading = true;

                    try {
                        // Test the secret by making a request
                        const response = await fetch('/api/categories', {
                            headers: { 'X-Admin-Secret': this.authSecretInput }
                        });

                        if (response.status === 401 || response.status === 403) {
                            this.authError = 'Invalid admin secret';
                            return;
                        }

                        if (!response.ok) {
                            this.authError = `Server error: ${response.status}`;
                            return;
                        }

                        // Success - save the secret
                        this.adminSecret = this.authSecretInput;
                        sessionStorage.setItem('adminSecret', this.adminSecret);
                        this.showAuthModal = false;
                        this.authSecretInput = '';

                        // Reload data now that we're authenticated
                        await Promise.all([
                            this.loadVideos(),
                            this.loadCategories()
                        ]);
                    } catch (e) {
                        this.authError = 'Failed to authenticate: ' + e.message;
                    } finally {
                        this.authLoading = false;
                    }
                },

                // Check if authentication is required
                async checkAuth() {
                    try {
                        const response = await fetch('/api/categories', {
                            headers: this.adminSecret ? { 'X-Admin-Secret': this.adminSecret } : {}
                        });

                        if (response.status === 401 || response.status === 403) {
                            this.authRequired = true;
                            this.showAuthModal = true;
                            this.adminSecret = '';
                            sessionStorage.removeItem('adminSecret');
                            return false;
                        }

                        if (!response.ok) {
                            console.error('Auth check failed with status:', response.status);
                            return false;
                        }

                        return true;
                    } catch (e) {
                        console.error('Auth check failed:', e);
                        return true; // Allow to continue on network errors
                    }
                },

                async init() {
                    // Check authentication first
                    const authOk = await this.checkAuth();
                    if (!authOk) {
                        // Focus the auth input after modal is shown
                        this.$nextTick(() => {
                            if (this.$refs.authInput) {
                                this.$refs.authInput.focus();
                            }
                        });
                        return;
                    }

                    await Promise.all([
                        this.loadVideos(),
                        this.loadCategories()
                    ]);

                    // Try to connect to SSE for real-time updates (falls back to polling)
                    this.connectProgressSSE();

                    // Auto-refresh videos every 30 seconds (longer interval since SSE handles progress)
                    setInterval(() => this.loadVideos(), 30000);

                    // Fallback polling for progress if SSE not connected
                    setInterval(() => {
                        if (!this.progressSSE || this.progressSSE.readyState !== EventSource.OPEN) {
                            this.loadProgressForActiveVideos();
                        }
                    }, 5000);

                    // Auto-refresh workers every 10 seconds when workers tab is active (SSE handles real-time)
                    setInterval(() => {
                        if (this.tab === 'workers' && (!this.workersSSE || this.workersSSE.readyState !== EventSource.OPEN)) {
                            this.loadWorkers();
                        }
                    }, 10000);

                    // Connect workers SSE when switching to workers tab
                    this.$watch('tab', (newTab) => {
                        if (newTab === 'workers') {
                            this.connectWorkersSSE();
                        }
                    });

                    // Cleanup SSE connections on page unload
                    window.addEventListener('beforeunload', () => {
                        if (this.progressSSE) {
                            this.progressSSE.close();
                        }
                        if (this.workersSSE) {
                            this.workersSSE.close();
                        }
                    });
                },

                async loadVideos() {
                    try {
                        const res = await this.apiFetch('/api/videos');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        this.videos = await res.json();
                        // Load progress for active videos after loading video list
                        await this.loadProgressForActiveVideos();
                    } catch (e) {
                        console.error('Failed to load videos:', e);
                        this.videos = [];
                    }
                },

                async loadProgressForActiveVideos() {
                    // Get videos that are processing or failed
                    const activeVideos = this.videos.filter(v =>
                        v.status === 'processing' || v.status === 'pending' || v.status === 'failed'
                    );

                    // Fetch progress for each
                    await Promise.all(activeVideos.map(async (video) => {
                        try {
                            const res = await this.apiFetch(`/api/videos/${video.id}/progress`);
                            if (res.ok) {
                                const data = await res.json();
                                this.progressData[video.id] = data;
                            }
                        } catch (e) {
                            console.error(`Failed to load progress for video ${video.id}:`, e);
                        }
                    }));
                },

                connectProgressSSE() {
                    // Close existing connection if any
                    if (this.progressSSE) {
                        this.progressSSE.close();
                    }

                    // Get video IDs that need progress tracking
                    const activeIds = this.videos
                        .filter(v => v.status === 'processing' || v.status === 'pending')
                        .map(v => v.id)
                        .join(',');

                    const url = activeIds
                        ? `/api/events/progress?video_ids=${activeIds}`
                        : '/api/events/progress';

                    try {
                        this.progressSSE = new EventSource(url);

                        this.progressSSE.addEventListener('progress', (e) => {
                            const data = JSON.parse(e.data);
                            this.progressData[data.video_id] = {
                                progress_percent: data.progress_percent,
                                current_step: data.current_step,
                                qualities: data.qualities,
                                last_error: data.last_error,
                                status: data.status
                            };
                        });

                        this.progressSSE.addEventListener('job_completed', (e) => {
                            const data = JSON.parse(e.data);
                            const video = this.videos.find(v => v.id === data.video_id);
                            if (video) {
                                video.status = 'ready';
                            }
                            delete this.progressData[data.video_id];
                            // Refresh video list to get updated qualities
                            this.loadVideos();
                        });

                        this.progressSSE.addEventListener('job_failed', (e) => {
                            const data = JSON.parse(e.data);
                            const video = this.videos.find(v => v.id === data.video_id);
                            if (video && !data.will_retry) {
                                video.status = 'failed';
                            }
                            if (this.progressData[data.video_id]) {
                                this.progressData[data.video_id].last_error = data.error;
                            }
                        });

                        this.progressSSE.addEventListener('initial', (e) => {
                            // Initial state from SSE connection
                            const data = JSON.parse(e.data);
                            if (data.progress) {
                                for (const [videoId, progress] of Object.entries(data.progress)) {
                                    this.progressData[parseInt(videoId)] = progress;
                                }
                            }
                        });

                        this.progressSSE.onopen = () => {
                            console.log('Progress SSE connected');
                            this.sseReconnectAttempts = 0;
                        };

                        this.progressSSE.onerror = (e) => {
                            console.warn('Progress SSE error, will reconnect:', e);
                            this.scheduleSSEReconnect('progress');
                        };
                    } catch (e) {
                        console.warn('Failed to create progress SSE:', e);
                    }
                },

                connectWorkersSSE() {
                    // Close existing connection if any
                    if (this.workersSSE) {
                        this.workersSSE.close();
                    }

                    try {
                        this.workersSSE = new EventSource('/api/events/workers');

                        this.workersSSE.addEventListener('initial', (e) => {
                            const data = JSON.parse(e.data);
                            if (data.workers) {
                                this.workersList = data.workers;
                                this.workerStats = {
                                    total_count: data.total_count,
                                    active_count: data.active_count,
                                    idle_count: data.idle_count,
                                    offline_count: data.offline_count,
                                    disabled_count: data.disabled_count
                                };
                            }
                            if (data.active_jobs) {
                                this.activeJobs = data.active_jobs;
                            }
                        });

                        this.workersSSE.addEventListener('worker_status', (e) => {
                            const data = JSON.parse(e.data);
                            // Update worker in list
                            const worker = this.workersList.find(w => w.worker_id === data.worker_id);
                            if (worker) {
                                worker.status = data.status;
                                worker.current_video_title = data.current_video_slug;
                                worker.current_step = data.current_step;
                                worker.current_progress = data.progress_percent;
                            }
                        });

                        this.workersSSE.addEventListener('job_completed', (e) => {
                            // Refresh active jobs on completion
                            this.loadActiveJobs();
                        });

                        this.workersSSE.addEventListener('job_failed', (e) => {
                            // Refresh active jobs on failure
                            this.loadActiveJobs();
                        });

                        this.workersSSE.addEventListener('progress', (e) => {
                            const data = JSON.parse(e.data);
                            // Update active job progress
                            if (this.activeJobs && this.activeJobs.jobs) {
                                const job = this.activeJobs.jobs.find(j => j.job_id === data.job_id);
                                if (job) {
                                    job.progress_percent = data.progress_percent;
                                    job.current_step = data.current_step;
                                    job.qualities = data.qualities;
                                }
                            }
                        });

                        this.workersSSE.onopen = () => {
                            console.log('Workers SSE connected');
                        };

                        this.workersSSE.onerror = (e) => {
                            console.warn('Workers SSE error, will reconnect:', e);
                            this.scheduleSSEReconnect('workers');
                        };
                    } catch (e) {
                        console.warn('Failed to create workers SSE:', e);
                    }
                },

                async loadActiveJobs() {
                    try {
                        const res = await this.apiFetch('/api/workers/active-jobs');
                        if (res.ok) {
                            this.activeJobs = await res.json();
                        }
                    } catch (e) {
                        console.error('Failed to load active jobs:', e);
                    }
                },

                scheduleSSEReconnect(type) {
                    this.sseReconnectAttempts++;
                    // Exponential backoff: 1s, 2s, 4s, 8s, ... up to max
                    const delay = Math.min(1000 * Math.pow(2, this.sseReconnectAttempts - 1), this.maxSseReconnectDelay);

                    setTimeout(() => {
                        if (type === 'progress') {
                            this.connectProgressSSE();
                        } else if (type === 'workers' && this.tab === 'workers') {
                            this.connectWorkersSSE();
                        }
                    }, delay);
                },

                async loadCategories() {
                    try {
                        const res = await this.apiFetch('/api/categories');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        this.categories = await res.json();
                    } catch (e) {
                        console.error('Failed to load categories:', e);
                        this.categories = [];
                    }
                },

                async uploadVideo() {
                    if (!this.uploadFile || !this.uploadTitle) return;

                    this.uploading = true;
                    this.uploadProgress = 0;
                    this.uploadMessage = '';
                    this.uploadError = false;

                    const formData = new FormData();
                    formData.append('file', this.uploadFile);
                    formData.append('title', this.uploadTitle);
                    formData.append('description', this.uploadDescription);
                    if (this.uploadCategory) {
                        formData.append('category_id', this.uploadCategory);
                    }

                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', '/api/videos', true);
                        if (this.adminSecret) {
                            xhr.setRequestHeader('X-Admin-Secret', this.adminSecret);
                        }

                        xhr.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                this.uploadProgress = Math.round((e.loaded / e.total) * 100);
                            }
                        };

                        xhr.onload = () => {
                            if (xhr.status === 200) {
                                this.uploadMessage = 'Video uploaded successfully! Processing will begin shortly.';
                                this.uploadError = false;
                                this.uploadFile = null;
                                this.uploadTitle = '';
                                this.uploadDescription = '';
                                this.uploadCategory = '';
                                this.loadVideos();
                            } else if (xhr.status === 401 || xhr.status === 403) {
                                this.authRequired = true;
                                this.showAuthModal = true;
                                this.adminSecret = '';
                                sessionStorage.removeItem('adminSecret');
                                this.uploadMessage = 'Authentication required';
                                this.uploadError = true;
                            } else {
                                this.uploadMessage = 'Upload failed: ' + xhr.responseText;
                                this.uploadError = true;
                            }
                            this.uploading = false;
                            this.uploadProgress = -1;
                        };

                        xhr.onerror = () => {
                            this.uploadMessage = 'Upload failed. Please try again.';
                            this.uploadError = true;
                            this.uploading = false;
                            this.uploadProgress = -1;
                        };

                        xhr.send(formData);
                    } catch (e) {
                        this.uploadMessage = 'Upload failed: ' + e.message;
                        this.uploadError = true;
                        this.uploading = false;
                        this.uploadProgress = -1;
                    }
                },

                async createCategory() {
                    if (!this.newCategoryName) return;

                    try {
                        const res = await this.apiFetch('/api/categories', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: this.newCategoryName,
                                description: this.newCategoryDesc
                            })
                        });

                        if (res.ok) {
                            this.newCategoryName = '';
                            this.newCategoryDesc = '';
                            await this.loadCategories();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to create category');
                        }
                    } catch (e) {
                        alert('Failed to create category: ' + e.message);
                    }
                },

                async deleteCategory(id) {
                    if (!confirm('Delete this category? Videos in it will become uncategorized.')) return;

                    try {
                        await this.apiFetch(`/api/categories/${id}`, { method: 'DELETE' });
                        await this.loadCategories();
                        await this.loadVideos();
                    } catch (e) {
                        alert('Failed to delete category: ' + e.message);
                    }
                },

                async deleteVideo(id) {
                    if (!confirm('Delete this video? This cannot be undone.')) return;

                    try {
                        await this.apiFetch(`/api/videos/${id}`, { method: 'DELETE' });
                        await this.loadVideos();
                    } catch (e) {
                        alert('Failed to delete video: ' + e.message);
                    }
                },

                async retryVideo(id) {
                    try {
                        await this.apiFetch(`/api/videos/${id}/retry`, { method: 'POST' });
                        await this.loadVideos();
                    } catch (e) {
                        alert('Failed to retry: ' + e.message);
                    }
                },

                async togglePublish(video) {
                    const action = video.published_at ? 'unpublish' : 'publish';
                    try {
                        await this.apiFetch(`/api/videos/${video.id}/${action}`, { method: 'POST' });
                        // Update the video in-place for instant feedback
                        video.published_at = action === 'publish' ? new Date().toISOString() : null;
                    } catch (e) {
                        alert(`Failed to ${action}: ` + e.message);
                    }
                },

                openReuploadModal(video) {
                    this.reuploadVideoId = video.id;
                    this.reuploadTitle = video.title;
                    this.reuploadFile = null;
                    this.reuploading = false;
                    this.reuploadProgress = -1;
                    this.reuploadMessage = '';
                    this.reuploadError = false;
                    this.reuploadModal = true;
                },

                async reuploadVideo() {
                    if (!this.reuploadFile) return;

                    this.reuploading = true;
                    this.reuploadProgress = 0;
                    this.reuploadMessage = '';
                    this.reuploadError = false;

                    const formData = new FormData();
                    formData.append('file', this.reuploadFile);

                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', `/api/videos/${this.reuploadVideoId}/re-upload`, true);
                        if (this.adminSecret) {
                            xhr.setRequestHeader('X-Admin-Secret', this.adminSecret);
                        }

                        xhr.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                this.reuploadProgress = Math.round((e.loaded / e.total) * 100);
                            }
                        };

                        xhr.onload = () => {
                            if (xhr.status === 200) {
                                this.reuploadMessage = 'Video uploaded successfully! Processing will begin shortly.';
                                this.reuploadError = false;
                                this.reuploadFile = null;
                                this.loadVideos();
                                // Close modal after a short delay so user sees success message
                                setTimeout(() => {
                                    this.reuploadModal = false;
                                }, 1500);
                            } else if (xhr.status === 401 || xhr.status === 403) {
                                this.authRequired = true;
                                this.showAuthModal = true;
                                this.adminSecret = '';
                                sessionStorage.removeItem('adminSecret');
                                this.reuploadMessage = 'Authentication required';
                                this.reuploadError = true;
                            } else {
                                let errorMsg = 'Re-upload failed';
                                try {
                                    const data = JSON.parse(xhr.responseText);
                                    errorMsg = data.detail || errorMsg;
                                } catch (e) {
                                    errorMsg = xhr.responseText || errorMsg;
                                }
                                this.reuploadMessage = errorMsg;
                                this.reuploadError = true;
                            }
                            this.reuploading = false;
                            this.reuploadProgress = -1;
                        };

                        xhr.onerror = () => {
                            this.reuploadMessage = 'Re-upload failed. Please try again.';
                            this.reuploadError = true;
                            this.reuploading = false;
                            this.reuploadProgress = -1;
                        };

                        xhr.send(formData);
                    } catch (e) {
                        this.reuploadMessage = 'Re-upload failed: ' + e.message;
                        this.reuploadError = true;
                        this.reuploading = false;
                        this.reuploadProgress = -1;
                    }
                },

                async openRetranscodeModal(video) {
                    this.retranscodeVideoId = video.id;
                    this.retranscodeTitle = video.title;
                    this.retranscodeSelected = [];
                    this.retranscoding = false;
                    this.retranscodeMessage = '';
                    this.retranscodeError = false;

                    // Fetch available qualities
                    try {
                        const res = await this.apiFetch(`/api/videos/${video.id}/qualities`);
                        if (res.ok) {
                            const data = await res.json();
                            this.retranscodeAvailable = data.available_qualities || [];
                            this.retranscodeExisting = data.existing_qualities || [];
                        } else {
                            this.retranscodeAvailable = [];
                            this.retranscodeExisting = [];
                        }
                    } catch (e) {
                        console.error('Failed to load qualities:', e);
                        this.retranscodeAvailable = [];
                        this.retranscodeExisting = [];
                    }

                    this.retranscodeModal = true;
                },

                async retranscodeAll(video) {
                    if (!confirm(`Re-transcode all qualities for "${video.title}"? This will delete all existing transcoded files and re-process the video.`)) return;

                    try {
                        const res = await this.apiFetch(`/api/videos/${video.id}/retranscode`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ qualities: ['all'] })
                        });

                        if (res.ok) {
                            await this.loadVideos();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Re-transcode failed');
                        }
                    } catch (e) {
                        alert('Re-transcode failed: ' + e.message);
                    }
                },

                async submitRetranscode() {
                    if (this.retranscodeSelected.length === 0) {
                        this.retranscodeMessage = 'Please select at least one quality';
                        this.retranscodeError = true;
                        return;
                    }

                    this.retranscoding = true;
                    this.retranscodeMessage = '';
                    this.retranscodeError = false;

                    try {
                        const res = await this.apiFetch(`/api/videos/${this.retranscodeVideoId}/retranscode`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ qualities: this.retranscodeSelected })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            this.retranscodeMessage = `Queued for re-transcoding: ${data.qualities_queued.join(', ')}`;
                            this.retranscodeError = false;
                            await this.loadVideos();
                            setTimeout(() => {
                                this.retranscodeModal = false;
                            }, 1500);
                        } else {
                            const data = await res.json();
                            this.retranscodeMessage = data.detail || 'Re-transcode failed';
                            this.retranscodeError = true;
                        }
                    } catch (e) {
                        this.retranscodeMessage = 'Re-transcode failed: ' + e.message;
                        this.retranscodeError = true;
                    }

                    this.retranscoding = false;
                },

                toggleRetranscodeQuality(quality) {
                    const idx = this.retranscodeSelected.indexOf(quality);
                    if (idx === -1) {
                        this.retranscodeSelected.push(quality);
                    } else {
                        this.retranscodeSelected.splice(idx, 1);
                    }
                },

                selectAllQualities() {
                    this.retranscodeSelected = [...this.retranscodeAvailable];
                },

                deselectAllQualities() {
                    this.retranscodeSelected = [];
                },

                getQualityStatus(quality) {
                    const existing = this.retranscodeExisting.find(q => q.name === quality);
                    return existing ? existing.status : 'not transcoded';
                },

                // Thumbnail selection methods
                openThumbnailModal(video) {
                    this.thumbnailVideoId = video.id;
                    this.thumbnailVideoSlug = video.slug;
                    this.thumbnailVideoTitle = video.title;
                    this.thumbnailDuration = video.duration;
                    this.thumbnailSource = video.thumbnail_source || 'auto';
                    this.thumbnailFrames = [];
                    this.thumbnailLoading = false;
                    this.thumbnailUploading = false;
                    this.thumbnailUploadFile = null;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;
                    this.thumbnailModal = true;
                },

                async generateThumbnailFrames() {
                    this.thumbnailLoading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/frames`, {
                            method: 'POST'
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to generate frames');
                        }

                        const data = await res.json();
                        this.thumbnailFrames = data.frames;
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailLoading = false;
                    }
                },

                async selectThumbnailFrame(timestamp) {
                    this.thumbnailLoading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const formData = new FormData();
                        formData.append('timestamp', timestamp);

                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/select`, {
                            method: 'POST',
                            body: formData
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to select frame');
                        }

                        this.thumbnailSource = 'selected';
                        this.thumbnailMessage = 'Thumbnail updated successfully';
                        this.thumbnailError = false;
                        await this.loadVideos();
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailLoading = false;
                    }
                },

                async uploadCustomThumbnail() {
                    if (!this.thumbnailUploadFile) return;

                    this.thumbnailUploading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const formData = new FormData();
                        formData.append('file', this.thumbnailUploadFile);

                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/upload`, {
                            method: 'POST',
                            body: formData
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to upload thumbnail');
                        }

                        this.thumbnailSource = 'custom';
                        this.thumbnailMessage = 'Thumbnail uploaded successfully';
                        this.thumbnailError = false;
                        this.thumbnailUploadFile = null;
                        await this.loadVideos();
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailUploading = false;
                    }
                },

                async revertThumbnail() {
                    this.thumbnailLoading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/revert`, {
                            method: 'POST'
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to revert thumbnail');
                        }

                        this.thumbnailSource = 'auto';
                        this.thumbnailMessage = 'Thumbnail reverted to auto-generated';
                        this.thumbnailError = false;
                        await this.loadVideos();
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailLoading = false;
                    }
                },

                openEditModal(video) {
                    this.editVideoId = video.id;
                    this.editTitle = video.title;
                    this.editDescription = video.description || '';
                    this.editCategory = video.category_id || 0;
                    // Convert ISO datetime to datetime-local format (YYYY-MM-DDTHH:MM)
                    if (video.published_at) {
                        this.editPublishedAt = video.published_at.slice(0, 16);
                    } else {
                        this.editPublishedAt = '';
                    }
                    this.editModal = true;
                },

                async saveVideo() {
                    if (!this.editTitle) return;

                    try {
                        const formData = new FormData();
                        formData.append('title', this.editTitle);
                        formData.append('description', this.editDescription);
                        formData.append('category_id', this.editCategory);
                        formData.append('published_at', this.editPublishedAt);

                        const res = await this.apiFetch(`/api/videos/${this.editVideoId}`, {
                            method: 'PUT',
                            body: formData
                        });

                        if (res.ok) {
                            this.editModal = false;
                            await this.loadVideos();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to update video');
                        }
                    } catch (e) {
                        alert('Failed to update video: ' + e.message);
                    }
                },

                formatDuration(seconds) {
                    if (!seconds) return '-';
                    const h = Math.floor(seconds / 3600);
                    const m = Math.floor((seconds % 3600) / 60);
                    const s = Math.floor(seconds % 60);
                    if (h > 0) {
                        return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                    }
                    return `${m}:${s.toString().padStart(2, '0')}`;
                },

                // Analytics methods
                async loadAnalytics() {
                    await Promise.all([
                        this.loadAnalyticsOverview(),
                        this.loadVideoAnalytics()
                    ]);
                },

                async loadAnalyticsOverview() {
                    try {
                        const res = await this.apiFetch('/api/analytics/overview');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        this.analyticsOverview = await res.json();
                    } catch (e) {
                        console.error('Failed to load analytics overview:', e);
                        this.analyticsOverview = {};
                    }
                },

                async loadVideoAnalytics() {
                    try {
                        const res = await this.apiFetch(`/api/analytics/videos?period=${this.analyticsPeriod}&limit=20&sort_by=views`);
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        const data = await res.json();
                        this.analyticsVideos = data.videos || [];
                    } catch (e) {
                        console.error('Failed to load video analytics:', e);
                        this.analyticsVideos = [];
                    }
                },

                formatHours(hours) {
                    if (!hours) return '0h';
                    if (hours < 1) return Math.round(hours * 60) + 'm';
                    return hours.toFixed(1) + 'h';
                },

                formatPercent(rate) {
                    if (rate === undefined || rate === null) return '0%';
                    return Math.round(rate * 100) + '%';
                },

                formatWatchTime(seconds) {
                    if (!seconds) return '0m';
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    if (hours > 0) return `${hours}h ${minutes}m`;
                    return `${minutes}m`;
                },

                // Worker management methods
                async loadWorkers() {
                    try {
                        const [workersRes, jobsRes] = await Promise.all([
                            this.apiFetch('/api/workers'),
                            this.apiFetch('/api/workers/active-jobs')
                        ]);

                        if (workersRes.ok) {
                            const data = await workersRes.json();
                            this.workersList = data.workers || [];
                            this.workerStats = {
                                total_count: data.total_count,
                                active_count: data.active_count,
                                idle_count: data.idle_count,
                                offline_count: data.offline_count,
                                disabled_count: data.disabled_count
                            };
                        } else {
                            console.error('Failed to load workers:', workersRes.status);
                            this.workersList = [];
                            this.workerStats = {};
                        }

                        if (jobsRes.ok) {
                            this.activeJobs = await jobsRes.json();
                        } else {
                            console.error('Failed to load active jobs:', jobsRes.status);
                            this.activeJobs = { jobs: [], total_count: 0, processing_count: 0, pending_count: 0 };
                        }
                    } catch (e) {
                        console.error('Failed to load workers:', e);
                        this.workersList = [];
                        this.workerStats = {};
                        this.activeJobs = { jobs: [], total_count: 0, processing_count: 0, pending_count: 0 };
                    }
                },

                async disableWorker(workerId) {
                    if (!confirm('Disable this worker? It will not be able to claim new jobs.')) return;

                    try {
                        const res = await this.apiFetch(`/api/workers/${workerId}/disable`, { method: 'PUT' });
                        if (res.ok) {
                            await this.loadWorkers();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to disable worker');
                        }
                    } catch (e) {
                        alert('Failed to disable worker: ' + e.message);
                    }
                },

                async enableWorker(workerId) {
                    try {
                        const res = await this.apiFetch(`/api/workers/${workerId}/enable`, { method: 'PUT' });
                        if (res.ok) {
                            await this.loadWorkers();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to enable worker');
                        }
                    } catch (e) {
                        alert('Failed to enable worker: ' + e.message);
                    }
                },

                async deleteWorker(workerId, workerName) {
                    const name = workerName || workerId.slice(0, 8);
                    if (!confirm(`Delete worker "${name}"? This will revoke its API key and remove it from the system.`)) return;

                    try {
                        const res = await this.apiFetch(`/api/workers/${workerId}`, { method: 'DELETE' });
                        if (res.ok) {
                            await this.loadWorkers();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to delete worker');
                        }
                    } catch (e) {
                        alert('Failed to delete worker: ' + e.message);
                    }
                },

                formatTimeSince(seconds) {
                    if (seconds === null || seconds === undefined) return '';
                    if (seconds < 60) return seconds + 's ago';
                    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
                    if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
                    return Math.floor(seconds / 86400) + 'd ago';
                },

                // Bulk operation methods
                toggleSelectAll() {
                    if (this.selectedVideos.length === this.videos.length) {
                        this.selectedVideos = [];
                    } else {
                        this.selectedVideos = this.videos.map(v => v.id);
                    }
                },

                toggleVideoSelection(videoId) {
                    const idx = this.selectedVideos.indexOf(videoId);
                    if (idx === -1) {
                        this.selectedVideos.push(videoId);
                    } else {
                        this.selectedVideos.splice(idx, 1);
                    }
                },

                clearSelection() {
                    this.selectedVideos = [];
                },

                openBulkDeleteModal() {
                    this.bulkDeletePermanent = false;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;
                    this.bulkDeleteModal = true;
                },

                openBulkUpdateModal() {
                    this.bulkUpdateCategory = '';
                    this.bulkUpdatePublishedAt = '';
                    this.bulkUpdateUnpublish = false;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;
                    this.bulkUpdateModal = true;
                },

                openBulkRetranscodeModal() {
                    this.bulkRetranscodeQuality = 'all';
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;
                    this.bulkRetranscodeModal = true;
                },

                async executeBulkDelete() {
                    this.bulkOpLoading = true;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/delete', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                video_ids: this.selectedVideos,
                                permanent: this.bulkDeletePermanent
                            })
                        });

                        const data = await res.json();
                        if (res.ok) {
                            this.bulkOpMessage = `Deleted ${data.deleted} video(s)` + (data.failed > 0 ? `, ${data.failed} failed` : '');
                            this.bulkOpError = data.failed > 0;
                            await this.loadVideos();
                            this.selectedVideos = [];
                            setTimeout(() => { this.bulkDeleteModal = false; }, 1500);
                        } else {
                            this.bulkOpMessage = data.detail || 'Delete failed';
                            this.bulkOpError = true;
                        }
                    } catch (e) {
                        this.bulkOpMessage = 'Delete failed: ' + e.message;
                        this.bulkOpError = true;
                    }

                    this.bulkOpLoading = false;
                },

                async executeBulkUpdate() {
                    // Build update payload
                    const payload = { video_ids: this.selectedVideos };

                    if (this.bulkUpdateCategory !== '') {
                        payload.category_id = parseInt(this.bulkUpdateCategory);
                    }
                    if (this.bulkUpdateUnpublish) {
                        payload.unpublish = true;
                    } else if (this.bulkUpdatePublishedAt) {
                        payload.published_at = this.bulkUpdatePublishedAt;
                    }

                    const hasUpdates = (payload.category_id !== undefined) || payload.unpublish || payload.published_at;
                    if (!hasUpdates) {
                        this.bulkOpMessage = 'Please select at least one field to update';
                        this.bulkOpError = true;
                        return;
                    }

                    this.bulkOpLoading = true;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/update', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        const data = await res.json();
                        if (res.ok) {
                            this.bulkOpMessage = `Updated ${data.updated} video(s)` + (data.failed > 0 ? `, ${data.failed} failed` : '');
                            this.bulkOpError = data.failed > 0;
                            await this.loadVideos();
                            this.selectedVideos = [];
                            setTimeout(() => { this.bulkUpdateModal = false; }, 1500);
                        } else {
                            this.bulkOpMessage = data.detail || 'Update failed';
                            this.bulkOpError = true;
                        }
                    } catch (e) {
                        this.bulkOpMessage = 'Update failed: ' + e.message;
                        this.bulkOpError = true;
                    }

                    this.bulkOpLoading = false;
                },

                async executeBulkRetranscode() {
                    this.bulkOpLoading = true;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/retranscode', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                video_ids: this.selectedVideos,
                                qualities: [this.bulkRetranscodeQuality]
                            })
                        });

                        const data = await res.json();
                        if (res.ok) {
                            this.bulkOpMessage = `Queued ${data.queued} video(s) for re-transcoding` + (data.failed > 0 ? `, ${data.failed} failed` : '');
                            this.bulkOpError = data.failed > 0;
                            await this.loadVideos();
                            this.selectedVideos = [];
                            setTimeout(() => { this.bulkRetranscodeModal = false; }, 1500);
                        } else {
                            this.bulkOpMessage = data.detail || 'Re-transcode failed';
                            this.bulkOpError = true;
                        }
                    } catch (e) {
                        this.bulkOpMessage = 'Re-transcode failed: ' + e.message;
                        this.bulkOpError = true;
                    }

                    this.bulkOpLoading = false;
                },

                async bulkRestoreVideos() {
                    if (!confirm(`Restore ${this.selectedVideos.length} video(s) from archive?`)) return;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/restore', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ video_ids: this.selectedVideos })
                        });

                        const data = await res.json();
                        if (res.ok) {
                            alert(`Restored ${data.restored} video(s)` + (data.failed > 0 ? `, ${data.failed} failed` : ''));
                            await this.loadVideos();
                            this.selectedVideos = [];
                        } else {
                            alert(data.detail || 'Restore failed');
                        }
                    } catch (e) {
                        alert('Restore failed: ' + e.message);
                    }
                },

                async exportVideos() {
                    try {
                        const res = await this.apiFetch('/api/videos/export');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        const data = await res.json();

                        // Create downloadable JSON file
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `vlog-export-${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        alert('Export failed: ' + e.message);
                    }
                }
            };
        }
    </script>
</body>
</html>
