<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; media-src 'self' blob: https://cdn.damenknight.com; connect-src 'self' https://cdn.damenknight.com; font-src 'self'; form-action 'self'; frame-ancestors 'none';">
    <title>VLog Admin</title>
    <link rel="stylesheet" href="/static/vendor/tailwind.css">
    <script src="/static/js/utils.js"></script>
    <script defer src="/static/vendor/alpine.min.js"></script>
    <style>
        [x-cloak] { display: none !important; }
    </style>
</head>
<body class="bg-dark-950 text-dark-100 min-h-screen" x-data="admin()">
    <!-- Header -->
    <header class="bg-dark-900 border-b border-dark-800">
        <div class="max-w-7xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <h1 class="text-2xl font-bold text-white">VLog Admin</h1>
                <div class="flex gap-4 items-center">
                    <button
                        @click="tab = 'videos'"
                        :class="tab === 'videos' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Videos</button>
                    <button
                        @click="tab = 'categories'"
                        :class="tab === 'categories' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Categories</button>
                    <button
                        @click="tab = 'upload'"
                        :class="tab === 'upload' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Upload</button>
                    <button
                        @click="tab = 'workers'; loadWorkers(); loadDeploymentHistory()"
                        :class="tab === 'workers' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Workers</button>
                    <button
                        @click="tab = 'analytics'; loadAnalytics()"
                        :class="tab === 'analytics' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Analytics</button>
                    <button
                        @click="tab = 'settings'; loadWatermarkSettings(); loadAllSettings()"
                        :class="tab === 'settings' ? 'text-blue-400' : 'text-dark-400 hover:text-white'"
                        class="font-medium"
                    >Settings</button>
                    <!-- Logout button - only shown when auth is enabled and user is logged in -->
                    <button
                        x-show="authRequired && isAuthenticated"
                        x-cloak
                        @click="logout()"
                        class="ml-4 px-3 py-1 text-sm text-dark-400 hover:text-red-400 border border-dark-700 hover:border-red-500 rounded transition"
                        title="Log out"
                    >Logout</button>
                </div>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-8">
        <!-- Upload Tab -->
        <div x-show="tab === 'upload'" x-cloak>
            <div class="bg-dark-900 rounded-xl p-6 max-w-2xl mx-auto">
                <h2 class="text-xl font-semibold mb-6">Upload Video</h2>

                <form @submit.prevent="uploadVideo" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium mb-2">Video File</label>
                        <input
                            type="file"
                            accept="video/*"
                            @change="uploadFile = $event.target.files[0]"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                            required
                        >
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Title</label>
                        <input
                            type="text"
                            x-model="uploadTitle"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                            placeholder="Video title"
                            required
                        >
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Description</label>
                        <textarea
                            x-model="uploadDescription"
                            rows="4"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                            placeholder="Video description (optional)"
                        ></textarea>
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Category</label>
                        <select
                            x-model="uploadCategory"
                            class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                        >
                            <option value="">No category</option>
                            <template x-for="cat in categories" :key="cat.id">
                                <option :value="cat.id" x-text="cat.name"></option>
                            </template>
                        </select>
                    </div>

                    <!-- Upload Progress -->
                    <div x-show="uploadProgress >= 0" class="space-y-2">
                        <div class="flex justify-between text-sm">
                            <span>Uploading...</span>
                            <span x-text="uploadProgress + '%'"></span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-2">
                            <div
                                class="bg-blue-500 h-2 rounded-full transition-all"
                                :style="'width: ' + uploadProgress + '%'"
                            ></div>
                        </div>
                    </div>

                    <div x-show="uploadMessage" :class="uploadError ? 'text-red-400' : 'text-green-400'" class="text-sm" x-text="uploadMessage"></div>

                    <button
                        type="submit"
                        :disabled="uploading"
                        class="w-full py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!uploading">Upload Video</span>
                        <span x-show="uploading">Uploading...</span>
                    </button>
                </form>
            </div>
        </div>

        <!-- Videos Tab -->
        <div x-show="tab === 'videos'" x-cloak>
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">All Videos</h2>
                <div class="flex gap-4 items-center">
                    <button @click="exportVideos" class="text-green-400 hover:text-green-300">Export</button>
                    <button @click="loadVideos" class="text-blue-400 hover:text-blue-300">Refresh</button>
                </div>
            </div>

            <!-- Bulk Action Toolbar -->
            <div x-show="selectedVideos.length > 0" class="bg-dark-800 rounded-lg p-3 mb-4 flex items-center gap-4">
                <span class="text-dark-300">
                    <span class="font-semibold text-white" x-text="selectedVideos.length"></span> video(s) selected
                </span>
                <div class="flex gap-2 ml-auto">
                    <button
                        @click="openBulkUpdateModal"
                        class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 rounded text-sm font-medium transition"
                    >Update</button>
                    <button
                        @click="openBulkRetranscodeModal"
                        class="px-3 py-1.5 bg-cyan-600 hover:bg-cyan-700 rounded text-sm font-medium transition"
                    >Re-transcode</button>
                    <button
                        @click="openBulkCustomFieldsModal"
                        x-show="customFields.length > 0"
                        class="px-3 py-1.5 bg-purple-600 hover:bg-purple-700 rounded text-sm font-medium transition"
                    >Custom Fields</button>
                    <button
                        @click="bulkRestoreVideos"
                        x-show="selectedVideos.some(id => videos.find(v => v.id === id)?.deleted_at)"
                        class="px-3 py-1.5 bg-green-600 hover:bg-green-700 rounded text-sm font-medium transition"
                    >Restore</button>
                    <button
                        @click="openBulkDeleteModal"
                        class="px-3 py-1.5 bg-red-600 hover:bg-red-700 rounded text-sm font-medium transition"
                    >Delete</button>
                    <button
                        @click="clearSelection"
                        class="px-3 py-1.5 bg-dark-600 hover:bg-dark-500 rounded text-sm font-medium transition"
                    >Clear</button>
                </div>
            </div>

            <div class="bg-dark-900 rounded-xl overflow-hidden">
                <table class="w-full">
                    <thead class="bg-dark-800">
                        <tr>
                            <th class="px-4 py-3 text-left text-sm font-medium w-10">
                                <input
                                    type="checkbox"
                                    :checked="selectedVideos.length === videos.length && videos.length > 0"
                                    @change="toggleSelectAll"
                                    class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"
                                >
                            </th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Thumbnail</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Title</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Category</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Status</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Duration</th>
                            <th class="px-4 py-3 text-left text-sm font-medium">Actions</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-dark-800">
                        <template x-for="video in videos" :key="video.id">
                            <tr class="hover:bg-dark-800/50" :class="{'bg-blue-900/20': selectedVideos.includes(video.id)}">
                                <td class="px-4 py-3">
                                    <input
                                        type="checkbox"
                                        :checked="selectedVideos.includes(video.id)"
                                        @change="toggleVideoSelection(video.id)"
                                        class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"
                                    >
                                </td>
                                <td class="px-4 py-3">
                                    <div class="w-24 aspect-video bg-dark-800 rounded overflow-hidden">
                                        <img
                                            :src="video.thumbnail_url"
                                            class="w-full h-full object-cover"
                                            @error="$el.style.display='none'"
                                        >
                                    </div>
                                </td>
                                <td class="px-4 py-3">
                                    <div class="font-medium" x-text="video.title"></div>
                                    <div class="text-dark-500 text-sm" x-text="video.slug"></div>
                                </td>
                                <td class="px-4 py-3 text-dark-400" x-text="video.category_name || '-'"></td>
                                <td class="px-4 py-3">
                                    <div class="space-y-1">
                                        <span
                                            :class="{
                                                'bg-green-500/20 text-green-400': video.status === 'ready',
                                                'bg-yellow-500/20 text-yellow-400': video.status === 'processing',
                                                'bg-blue-500/20 text-blue-400': video.status === 'pending',
                                                'bg-red-500/20 text-red-400': video.status === 'failed'
                                            }"
                                            class="px-2 py-1 rounded text-sm"
                                            x-text="video.status"
                                        ></span>
                                        <span
                                            x-show="video.status === 'ready'"
                                            :class="video.published_at ? 'bg-emerald-500/20 text-emerald-400' : 'bg-dark-600 text-dark-400'"
                                            class="px-2 py-1 rounded text-sm"
                                            x-text="video.published_at ? 'published' : 'draft'"
                                        ></span>
                                        <!-- Progress details for processing videos -->
                                        <template x-if="video.status === 'processing' && progressData[video.id]">
                                            <div class="text-xs space-y-1 mt-2">
                                                <div class="flex items-center gap-2">
                                                    <div class="flex-1 bg-dark-700 rounded-full h-1.5">
                                                        <div
                                                            class="bg-yellow-500 h-1.5 rounded-full transition-all"
                                                            :style="'width: ' + (progressData[video.id]?.progress_percent || 0) + '%'"
                                                        ></div>
                                                    </div>
                                                    <span class="text-dark-400 w-8" x-text="(progressData[video.id]?.progress_percent || 0) + '%'"></span>
                                                </div>
                                                <div class="text-dark-500" x-text="progressData[video.id]?.current_step || ''"></div>
                                                <template x-if="progressData[video.id]?.qualities?.length">
                                                    <div class="flex flex-wrap gap-1 mt-1">
                                                        <template x-for="q in progressData[video.id].qualities" :key="q.name">
                                                            <span
                                                                :class="{
                                                                    'bg-green-500/20 text-green-400': q.status === 'completed' || q.status === 'uploaded',
                                                                    'bg-yellow-500/20 text-yellow-400': q.status === 'in_progress',
                                                                    'bg-dark-700 text-dark-400': q.status === 'pending'
                                                                }"
                                                                class="px-1.5 py-0.5 rounded text-xs"
                                                            >
                                                                <span x-text="q.name"></span>
                                                                <span x-show="q.status === 'in_progress'" x-text="' ' + q.progress + '%'"></span>
                                                            </span>
                                                        </template>
                                                    </div>
                                                </template>
                                            </div>
                                        </template>
                                        <!-- Pending indicator -->
                                        <template x-if="video.status === 'pending'">
                                            <div class="text-xs text-dark-500 mt-1">Waiting for worker...</div>
                                        </template>
                                        <!-- Error message for failed -->
                                        <template x-if="video.status === 'failed' && progressData[video.id]?.last_error">
                                            <div class="text-xs text-red-400 mt-1 max-w-xs truncate" x-text="progressData[video.id].last_error"></div>
                                        </template>
                                    </div>
                                </td>
                                <td class="px-4 py-3 text-dark-400" x-text="formatDuration(video.duration)"></td>
                                <td class="px-4 py-3">
                                    <div class="flex gap-2 flex-wrap">
                                        <button
                                            @click="openEditModal(video)"
                                            class="text-blue-400 hover:text-blue-300 text-sm"
                                        >Edit</button>
                                        <button
                                            x-show="video.status !== 'processing'"
                                            @click="openReuploadModal(video)"
                                            class="text-purple-400 hover:text-purple-300 text-sm"
                                        >Re-upload</button>
                                        <!-- Re-transcode dropdown -->
                                        <div class="relative" x-data="{ open: false }">
                                            <button
                                                @click="open = !open"
                                                @click.away="open = false"
                                                class="text-cyan-400 hover:text-cyan-300 text-sm"
                                            >Re-transcode</button>
                                            <div
                                                x-show="open"
                                                x-cloak
                                                class="absolute left-0 mt-1 w-36 bg-dark-800 border border-dark-700 rounded-lg shadow-lg z-10"
                                            >
                                                <button
                                                    @click="retranscodeAll(video); open = false"
                                                    class="w-full text-left px-3 py-2 text-sm hover:bg-dark-700 rounded-t-lg"
                                                >All Qualities</button>
                                                <button
                                                    @click="openRetranscodeModal(video); open = false"
                                                    class="w-full text-left px-3 py-2 text-sm hover:bg-dark-700 rounded-b-lg"
                                                >Select Qualities...</button>
                                            </div>
                                        </div>
                                        <button
                                            x-show="video.status === 'failed'"
                                            @click="retryVideo(video.id)"
                                            class="text-yellow-400 hover:text-yellow-300 text-sm"
                                        >Retry</button>
                                        <button
                                            x-show="video.status === 'ready'"
                                            @click="togglePublish(video)"
                                            :class="video.published_at ? 'text-orange-400 hover:text-orange-300' : 'text-emerald-400 hover:text-emerald-300'"
                                            class="text-sm"
                                            x-text="video.published_at ? 'Unpublish' : 'Publish'"
                                        ></button>
                                        <button
                                            x-show="video.status === 'ready'"
                                            @click="openThumbnailModal(video)"
                                            class="text-green-400 hover:text-green-300 text-sm"
                                        >Thumbnail</button>
                                        <button
                                            @click="deleteVideo(video.id)"
                                            class="text-red-400 hover:text-red-300 text-sm"
                                        >Delete</button>
                                    </div>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>

                <div x-show="videos.length === 0" class="text-center py-8 text-dark-400">
                    No videos yet. Upload your first video!
                </div>
            </div>
        </div>

        <!-- Categories Tab -->
        <div x-show="tab === 'categories'" x-cloak>
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">Categories</h2>
            </div>

            <div class="grid md:grid-cols-2 gap-6">
                <!-- Add Category -->
                <div class="bg-dark-900 rounded-xl p-6">
                    <h3 class="font-medium mb-4">Add Category</h3>
                    <form @submit.prevent="createCategory" class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">Name</label>
                            <input
                                type="text"
                                x-model="newCategoryName"
                                class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                placeholder="Category name"
                                required
                            >
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Description</label>
                            <textarea
                                x-model="newCategoryDesc"
                                rows="2"
                                class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                placeholder="Optional description"
                            ></textarea>
                        </div>
                        <button
                            type="submit"
                            class="w-full py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition"
                        >Add Category</button>
                    </form>
                </div>

                <!-- Category List -->
                <div class="bg-dark-900 rounded-xl p-6">
                    <h3 class="font-medium mb-4">Existing Categories</h3>
                    <div class="space-y-2">
                        <template x-for="cat in categories" :key="cat.id">
                            <div class="flex justify-between items-center p-3 bg-dark-800 rounded-lg">
                                <div>
                                    <div class="font-medium" x-text="cat.name"></div>
                                    <div class="text-dark-500 text-sm" x-text="cat.video_count + ' videos'"></div>
                                </div>
                                <button
                                    @click="deleteCategory(cat.id)"
                                    class="text-red-400 hover:text-red-300 text-sm"
                                >Delete</button>
                            </div>
                        </template>
                        <div x-show="categories.length === 0" class="text-dark-400 text-center py-4">
                            No categories yet.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div x-show="tab === 'analytics'" x-cloak>
            <!-- Overview Cards -->
            <div class="grid grid-cols-3 gap-4 mb-8">
                <div class="bg-dark-900 rounded-xl p-6">
                    <div class="text-dark-400 text-sm mb-1">Total Views</div>
                    <div class="text-2xl font-bold" x-text="analyticsOverview.total_views?.toLocaleString() || '0'"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-6">
                    <div class="text-dark-400 text-sm mb-1">Watch Time</div>
                    <div class="text-2xl font-bold" x-text="formatHours(analyticsOverview.total_watch_time_hours)"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-6">
                    <div class="text-dark-400 text-sm mb-1">Completion Rate</div>
                    <div class="text-2xl font-bold" x-text="formatPercent(analyticsOverview.completion_rate)"></div>
                </div>
            </div>

            <!-- Period Stats -->
            <div class="grid grid-cols-3 gap-4 mb-8">
                <div class="bg-dark-800 rounded-lg p-4 text-center">
                    <div class="text-dark-400 text-xs uppercase mb-1">Today</div>
                    <div class="text-lg font-semibold" x-text="analyticsOverview.views_today || 0"></div>
                </div>
                <div class="bg-dark-800 rounded-lg p-4 text-center">
                    <div class="text-dark-400 text-xs uppercase mb-1">This Week</div>
                    <div class="text-lg font-semibold" x-text="analyticsOverview.views_this_week || 0"></div>
                </div>
                <div class="bg-dark-800 rounded-lg p-4 text-center">
                    <div class="text-dark-400 text-xs uppercase mb-1">This Month</div>
                    <div class="text-lg font-semibold" x-text="analyticsOverview.views_this_month || 0"></div>
                </div>
            </div>

            <!-- Top Videos Table -->
            <div class="bg-dark-900 rounded-xl overflow-hidden">
                <div class="px-6 py-4 border-b border-dark-800 flex justify-between items-center">
                    <h3 class="font-semibold">Top Videos</h3>
                    <select x-model="analyticsPeriod" @change="loadVideoAnalytics" class="bg-dark-800 border border-dark-700 rounded px-3 py-1 text-sm">
                        <option value="all">All Time</option>
                        <option value="month">This Month</option>
                        <option value="week">This Week</option>
                        <option value="day">Today</option>
                    </select>
                </div>
                <table class="w-full">
                    <thead class="bg-dark-800">
                        <tr>
                            <th class="px-4 py-3 text-left text-sm font-medium">Video</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Views</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Watch Time</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Avg Duration</th>
                            <th class="px-4 py-3 text-right text-sm font-medium">Completion</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-dark-800">
                        <template x-for="video in analyticsVideos" :key="video.video_id">
                            <tr class="hover:bg-dark-800/50">
                                <td class="px-4 py-3">
                                    <div class="flex items-center gap-3">
                                        <div class="w-16 aspect-video bg-dark-800 rounded overflow-hidden flex-shrink-0">
                                            <img :src="video.thumbnail_url" class="w-full h-full object-cover" @error="$el.style.display='none'">
                                        </div>
                                        <div class="font-medium truncate max-w-xs" x-text="video.title"></div>
                                    </div>
                                </td>
                                <td class="px-4 py-3 text-right" x-text="video.total_views.toLocaleString()"></td>
                                <td class="px-4 py-3 text-right text-dark-400" x-text="formatWatchTime(video.total_watch_time_seconds)"></td>
                                <td class="px-4 py-3 text-right text-dark-400" x-text="formatDuration(video.avg_watch_duration_seconds)"></td>
                                <td class="px-4 py-3 text-right" x-text="formatPercent(video.completion_rate)"></td>
                            </tr>
                        </template>
                    </tbody>
                </table>
                <div x-show="analyticsVideos.length === 0" class="text-center py-8 text-dark-400">
                    No playback data yet. Views will appear here once videos are watched.
                </div>
            </div>
        </div>

        <!-- Workers Tab -->
        <div x-show="tab === 'workers'" x-cloak>
            <!-- Worker Status Summary -->
            <div class="grid grid-cols-5 gap-4 mb-6">
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-dark-400 text-sm mb-1">Total</div>
                    <div class="text-2xl font-bold" x-text="workerStats.total_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-green-400 text-sm mb-1">Active</div>
                    <div class="text-2xl font-bold text-green-400" x-text="workerStats.active_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-blue-400 text-sm mb-1">Idle</div>
                    <div class="text-2xl font-bold text-blue-400" x-text="workerStats.idle_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-red-400 text-sm mb-1">Offline</div>
                    <div class="text-2xl font-bold text-red-400" x-text="workerStats.offline_count || 0"></div>
                </div>
                <div class="bg-dark-900 rounded-xl p-4 text-center">
                    <div class="text-dark-500 text-sm mb-1">Disabled</div>
                    <div class="text-2xl font-bold text-dark-500" x-text="workerStats.disabled_count || 0"></div>
                </div>
            </div>

            <!-- Workers List -->
            <div class="bg-dark-900 rounded-xl overflow-hidden mb-6">
                <div class="px-6 py-4 border-b border-dark-800 flex justify-between items-center">
                    <h3 class="font-semibold">Workers</h3>
                    <div class="flex gap-3">
                        <button
                            @click="restartAllWorkers"
                            x-show="workersList.filter(w => w.status !== 'offline' && w.status !== 'disabled').length > 0"
                            class="text-purple-400 hover:text-purple-300 text-sm"
                            title="Restart all online workers (useful for deploying updates)"
                        >Restart All</button>
                        <button @click="loadWorkers" class="text-blue-400 hover:text-blue-300 text-sm">Refresh</button>
                    </div>
                </div>

                <div class="divide-y divide-dark-800">
                    <template x-for="worker in workersList" :key="worker.id">
                        <div class="p-4 hover:bg-dark-800/50">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center gap-3">
                                    <!-- Status indicator -->
                                    <div
                                        :class="{
                                            'bg-green-500': worker.status === 'active',
                                            'bg-blue-500': worker.status === 'idle',
                                            'bg-red-500': worker.status === 'offline',
                                            'bg-dark-600': worker.status === 'disabled'
                                        }"
                                        class="w-3 h-3 rounded-full"
                                    ></div>
                                    <div>
                                        <div class="font-medium" x-text="worker.worker_name || worker.worker_id.slice(0, 8)"></div>
                                        <div class="text-dark-500 text-sm flex items-center gap-2">
                                            <span :class="{
                                                'text-green-400': worker.status === 'active',
                                                'text-blue-400': worker.status === 'idle',
                                                'text-red-400': worker.status === 'offline',
                                                'text-dark-500': worker.status === 'disabled'
                                            }" x-text="worker.status.charAt(0).toUpperCase() + worker.status.slice(1)"></span>
                                            <span class="text-dark-600">•</span>
                                            <span x-text="worker.hwaccel_type ? (worker.gpu_name || worker.hwaccel_type.toUpperCase()) : 'CPU'"></span>
                                            <!-- Version and deployment info -->
                                            <template x-if="worker.code_version">
                                                <span class="text-dark-600">•</span>
                                            </template>
                                            <template x-if="worker.code_version">
                                                <span
                                                    :class="{
                                                        'text-yellow-400': isVersionOutdated(worker.code_version),
                                                        'text-dark-400': !isVersionOutdated(worker.code_version)
                                                    }"
                                                    :title="isVersionOutdated(worker.code_version) ? 'Outdated version' : 'Current version'"
                                                    x-text="worker.code_version"
                                                ></span>
                                            </template>
                                            <template x-if="worker.deployment_type">
                                                <span class="text-dark-600">•</span>
                                            </template>
                                            <template x-if="worker.deployment_type">
                                                <span class="text-dark-500" x-text="worker.deployment_type === 'kubernetes' ? 'k8s' : worker.deployment_type"></span>
                                            </template>
                                            <template x-if="worker.seconds_since_heartbeat !== null">
                                                <span class="text-dark-600">•</span>
                                            </template>
                                            <template x-if="worker.seconds_since_heartbeat !== null">
                                                <span
                                                    :class="{
                                                        'text-green-400': worker.seconds_since_heartbeat < 30,
                                                        'text-yellow-400': worker.seconds_since_heartbeat >= 30 && worker.seconds_since_heartbeat < 120,
                                                        'text-red-400': worker.seconds_since_heartbeat >= 120
                                                    }"
                                                    x-text="formatTimeSince(worker.seconds_since_heartbeat)"
                                                ></span>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center gap-4">
                                    <!-- Stats -->
                                    <div class="text-right text-sm">
                                        <div class="text-dark-400">
                                            <span class="text-green-400" x-text="worker.jobs_completed"></span> completed
                                            <template x-if="worker.jobs_failed > 0">
                                                <span>, <span class="text-red-400" x-text="worker.jobs_failed"></span> failed</span>
                                            </template>
                                        </div>
                                    </div>
                                    <!-- Actions -->
                                    <div class="flex gap-2">
                                        <!-- Monitoring buttons (require online worker) -->
                                        <button
                                            x-show="worker.status !== 'disabled' && worker.status !== 'offline'"
                                            @click="viewWorkerLogs(worker.worker_id, worker.worker_name)"
                                            class="text-cyan-400 hover:text-cyan-300 text-sm"
                                            title="View worker logs"
                                        >Logs</button>
                                        <button
                                            x-show="worker.status !== 'disabled' && worker.status !== 'offline'"
                                            @click="viewWorkerMetrics(worker.worker_id, worker.worker_name)"
                                            class="text-green-400 hover:text-green-300 text-sm"
                                            title="View worker metrics"
                                        >Metrics</button>
                                        <span x-show="worker.status !== 'disabled' && worker.status !== 'offline'" class="text-dark-600">|</span>
                                        <!-- Remote control buttons (require online worker) -->
                                        <button
                                            x-show="worker.status !== 'disabled' && worker.status !== 'offline'"
                                            @click="restartWorker(worker.worker_id, worker.worker_name)"
                                            :disabled="workerCommandPending[worker.worker_id]"
                                            class="text-blue-400 hover:text-blue-300 text-sm disabled:opacity-50"
                                            :title="workerCommandPending[worker.worker_id] ? 'Command pending...' : 'Restart worker (after current job)'"
                                        >Restart</button>
                                        <button
                                            x-show="worker.status !== 'disabled' && worker.status !== 'offline'"
                                            @click="updateWorker(worker.worker_id, worker.worker_name)"
                                            :disabled="workerCommandPending[worker.worker_id]"
                                            class="text-purple-400 hover:text-purple-300 text-sm disabled:opacity-50"
                                            title="Pull latest code and restart"
                                        >Update</button>
                                        <span x-show="worker.status !== 'disabled' && worker.status !== 'offline'" class="text-dark-600">|</span>
                                        <!-- Status control buttons -->
                                        <button
                                            x-show="worker.status !== 'disabled'"
                                            @click="disableWorker(worker.worker_id)"
                                            class="text-yellow-400 hover:text-yellow-300 text-sm"
                                        >Disable</button>
                                        <button
                                            x-show="worker.status === 'disabled'"
                                            @click="enableWorker(worker.worker_id)"
                                            class="text-green-400 hover:text-green-300 text-sm"
                                        >Enable</button>
                                        <button
                                            @click="deleteWorker(worker.worker_id, worker.worker_name)"
                                            class="text-red-400 hover:text-red-300 text-sm"
                                        >Delete</button>
                                    </div>
                                </div>
                            </div>
                            <!-- Current job info -->
                            <template x-if="worker.current_video_title">
                                <div class="mt-2 ml-6 text-sm">
                                    <div class="flex items-center gap-2">
                                        <span class="text-dark-400">Processing:</span>
                                        <span class="text-white" x-text="worker.current_video_title"></span>
                                        <span class="text-dark-500" x-text="'(' + worker.current_step + ')'"></span>
                                    </div>
                                    <div class="flex items-center gap-2 mt-1">
                                        <div class="flex-1 max-w-xs bg-dark-700 rounded-full h-1.5">
                                            <div
                                                class="bg-green-500 h-1.5 rounded-full transition-all"
                                                :style="'width: ' + (worker.current_progress || 0) + '%'"
                                            ></div>
                                        </div>
                                        <span class="text-dark-400 text-xs" x-text="(worker.current_progress || 0) + '%'"></span>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>

                <div x-show="workersList.length === 0" class="text-center py-8 text-dark-400">
                    No workers registered. Use <code class="bg-dark-800 px-2 py-1 rounded">vlog worker register</code> to add workers.
                </div>
            </div>

            <!-- Active Jobs -->
            <div class="bg-dark-900 rounded-xl overflow-hidden">
                <div class="px-6 py-4 border-b border-dark-800 flex justify-between items-center">
                    <h3 class="font-semibold">
                        Active Transcoding Jobs
                        <span class="text-dark-500 font-normal" x-text="'(' + (activeJobs.processing_count || 0) + ' processing, ' + (activeJobs.pending_count || 0) + ' pending)'"></span>
                    </h3>
                </div>

                <div class="divide-y divide-dark-800">
                    <template x-for="job in activeJobs.jobs" :key="job.job_id">
                        <div class="p-4">
                            <div class="flex items-start gap-4">
                                <!-- Video info -->
                                <div class="flex-1">
                                    <div class="font-medium" x-text="job.video_title"></div>
                                    <div class="text-dark-500 text-sm flex items-center gap-2 mt-1">
                                        <template x-if="job.worker_name">
                                            <span>
                                                Worker: <span class="text-white" x-text="job.worker_name"></span>
                                                <span x-show="job.worker_hwaccel_type" class="text-dark-400" x-text="'(' + job.worker_hwaccel_type + ')'"></span>
                                            </span>
                                        </template>
                                        <template x-if="!job.worker_name && job.status === 'pending'">
                                            <span class="text-blue-400">Waiting for worker...</span>
                                        </template>
                                    </div>
                                </div>
                                <!-- Progress -->
                                <div class="w-48">
                                    <div class="flex items-center justify-between text-sm mb-1">
                                        <span
                                            :class="{
                                                'text-yellow-400': job.status === 'processing',
                                                'text-blue-400': job.status === 'pending'
                                            }"
                                            x-text="job.current_step || job.status"
                                        ></span>
                                        <span class="text-dark-400" x-text="job.progress_percent + '%'"></span>
                                    </div>
                                    <div class="w-full bg-dark-700 rounded-full h-2">
                                        <div
                                            :class="{
                                                'bg-yellow-500': job.status === 'processing',
                                                'bg-blue-500': job.status === 'pending'
                                            }"
                                            class="h-2 rounded-full transition-all"
                                            :style="'width: ' + job.progress_percent + '%'"
                                        ></div>
                                    </div>
                                    <!-- Quality badges -->
                                    <template x-if="job.qualities && job.qualities.length > 0">
                                        <div class="flex flex-wrap gap-1 mt-2">
                                            <template x-for="q in job.qualities" :key="q.name">
                                                <span
                                                    :class="{
                                                        'bg-green-500/20 text-green-400': q.status === 'completed' || q.status === 'uploaded',
                                                        'bg-yellow-500/20 text-yellow-400': q.status === 'in_progress',
                                                        'bg-dark-700 text-dark-400': q.status === 'pending'
                                                    }"
                                                    class="px-1.5 py-0.5 rounded text-xs"
                                                >
                                                    <span x-text="q.name"></span>
                                                    <span x-show="q.status === 'in_progress'" x-text="' ' + q.progress + '%'"></span>
                                                </span>
                                            </template>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>

                <div x-show="!activeJobs.jobs || activeJobs.jobs.length === 0" class="text-center py-8 text-dark-400">
                    No active transcoding jobs.
                </div>
            </div>

            <!-- Deployment History -->
            <div class="bg-dark-900 rounded-xl overflow-hidden mt-6">
                <div class="px-6 py-4 border-b border-dark-800 flex justify-between items-center">
                    <h3 class="font-semibold">
                        Deployment History
                        <span class="text-dark-500 font-normal" x-text="'(' + deploymentEvents.length + ' events)'"></span>
                    </h3>
                    <button @click="loadDeploymentHistory" class="text-blue-400 hover:text-blue-300 text-sm">Refresh</button>
                </div>

                <!-- Loading state -->
                <div x-show="deploymentEventsLoading" class="text-center py-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-2 border-dark-700 border-t-blue-500 mx-auto"></div>
                </div>

                <!-- Events list -->
                <div x-show="!deploymentEventsLoading && deploymentEvents.length > 0" class="divide-y divide-dark-800">
                    <template x-for="event in deploymentEvents" :key="event.id">
                        <div class="p-4 hover:bg-dark-800/50">
                            <div class="flex items-center gap-4">
                                <!-- Event type indicator -->
                                <div
                                    :class="getEventColor(event.event_type, event.status)"
                                    class="w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-bold"
                                    x-text="getEventIcon(event.event_type)"
                                ></div>
                                <!-- Event details -->
                                <div class="flex-1">
                                    <div class="flex items-center gap-2">
                                        <span class="font-medium capitalize" x-text="event.event_type.replace('_', ' ')"></span>
                                        <span class="text-dark-500">-</span>
                                        <span class="text-dark-300" x-text="event.worker_name || event.worker_id.slice(0, 8)"></span>
                                        <template x-if="event.status !== 'completed'">
                                            <span
                                                :class="{
                                                    'text-yellow-400': event.status === 'pending' || event.status === 'in_progress',
                                                    'text-red-400': event.status === 'failed'
                                                }"
                                                class="text-sm"
                                                x-text="'(' + event.status + ')'"
                                            ></span>
                                        </template>
                                    </div>
                                    <div class="text-dark-500 text-sm flex items-center gap-2 mt-1">
                                        <span x-text="formatDeploymentTime(event.created_at)"></span>
                                        <template x-if="event.old_version || event.new_version">
                                            <span class="text-dark-600">|</span>
                                        </template>
                                        <template x-if="event.old_version || event.new_version">
                                            <span>
                                                <template x-if="event.old_version">
                                                    <span class="text-dark-400" x-text="event.old_version"></span>
                                                </template>
                                                <template x-if="event.old_version && event.new_version">
                                                    <span class="text-dark-600 mx-1">→</span>
                                                </template>
                                                <template x-if="event.new_version">
                                                    <span class="text-green-400" x-text="event.new_version"></span>
                                                </template>
                                            </span>
                                        </template>
                                        <template x-if="event.triggered_by">
                                            <span class="text-dark-600">|</span>
                                        </template>
                                        <template x-if="event.triggered_by">
                                            <span class="text-dark-400" x-text="'by ' + event.triggered_by"></span>
                                        </template>
                                    </div>
                                    <template x-if="event.details">
                                        <div class="text-dark-400 text-sm mt-1" x-text="event.details"></div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>

                <div x-show="!deploymentEventsLoading && deploymentEvents.length === 0" class="text-center py-8 text-dark-400">
                    No deployment events recorded yet.
                </div>
            </div>
        </div>
        <!-- Settings Tab -->
        <div x-show="tab === 'settings'" x-cloak>
            <div class="max-w-5xl">
                <div class="flex items-center justify-between mb-6">
                    <h2 class="text-xl font-semibold">Settings</h2>
                    <!-- Import/Export buttons -->
                    <div class="flex gap-2">
                        <button
                            @click="exportSettings()"
                            class="px-3 py-1.5 text-sm bg-dark-800 hover:bg-dark-700 border border-dark-700 rounded-lg transition flex items-center gap-2"
                        >
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                            </svg>
                            Export
                        </button>
                        <label class="px-3 py-1.5 text-sm bg-dark-800 hover:bg-dark-700 border border-dark-700 rounded-lg transition flex items-center gap-2 cursor-pointer">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                            </svg>
                            Import
                            <input type="file" accept=".json" @change="importSettings($event)" class="hidden">
                        </label>
                    </div>
                </div>

                <!-- Settings sub-tabs -->
                <div class="flex gap-2 mb-6 flex-wrap">
                    <button
                        @click="settingsTab = 'watermark'"
                        :class="settingsTab === 'watermark' ? 'bg-blue-600 text-white' : 'bg-dark-800 text-dark-300 hover:bg-dark-700'"
                        class="px-4 py-2 rounded-lg font-medium transition text-sm"
                    >Watermark</button>
                    <button
                        @click="settingsTab = 'custom_fields'; loadCustomFields()"
                        :class="settingsTab === 'custom_fields' ? 'bg-blue-600 text-white' : 'bg-dark-800 text-dark-300 hover:bg-dark-700'"
                        class="px-4 py-2 rounded-lg font-medium transition text-sm"
                    >Custom Fields</button>
                    <template x-for="category in settingsCategories" :key="category">
                        <button
                            @click="settingsTab = category"
                            :class="settingsTab === category ? 'bg-blue-600 text-white' : 'bg-dark-800 text-dark-300 hover:bg-dark-700'"
                            class="px-4 py-2 rounded-lg font-medium transition text-sm capitalize"
                            x-text="category.replace(/_/g, ' ')"
                        ></button>
                    </template>
                </div>

                <!-- Global settings message -->
                <div x-show="settingsMessage" class="mb-4">
                    <div :class="settingsError ? 'bg-red-900/20 border-red-800 text-red-400' : 'bg-green-900/20 border-green-800 text-green-400'" class="border rounded-lg px-4 py-3 text-sm flex items-center justify-between">
                        <span x-text="settingsMessage"></span>
                        <button @click="settingsMessage = ''" class="text-dark-400 hover:text-white">&times;</button>
                    </div>
                </div>

                <!-- Watermark Settings (special case with file upload) -->
                <div x-show="settingsTab === 'watermark'" class="bg-dark-900 rounded-xl p-6">
                    <h3 class="text-lg font-semibold mb-4">Watermark</h3>
                    <p class="text-dark-400 text-sm mb-6">
                        Add a logo or text overlay to videos. The watermark is displayed client-side and does not modify the original video files.
                    </p>

                    <!-- Loading state -->
                    <div x-show="watermarkLoading" class="text-center py-8">
                        <div class="animate-spin rounded-full h-8 w-8 border-2 border-dark-700 border-t-blue-500 mx-auto"></div>
                    </div>

                    <!-- Settings content -->
                    <div x-show="!watermarkLoading && watermarkSettings" class="space-y-6">
                        <!-- Current Status -->
                        <div class="flex items-center gap-4 p-4 rounded-lg" :class="watermarkSettings.enabled ? 'bg-green-900/20 border border-green-800' : 'bg-dark-800'">
                            <div class="flex-1">
                                <div class="font-medium" x-text="watermarkSettings.enabled ? 'Watermark Enabled' : 'Watermark Disabled'"></div>
                                <div class="text-sm text-dark-400" x-show="watermarkSettings.enabled">
                                    Type: <span class="text-dark-200" x-text="watermarkSettings.type"></span> |
                                    Position: <span class="text-dark-200" x-text="watermarkSettings.position"></span> |
                                    Opacity: <span class="text-dark-200" x-text="(watermarkSettings.opacity * 100).toFixed(0) + '%'"></span>
                                </div>
                            </div>
                            <div x-show="watermarkSettings.enabled" class="text-green-400">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                            </div>
                        </div>

                        <!-- Image Watermark Section -->
                        <div class="border-t border-dark-800 pt-6">
                            <h4 class="font-medium mb-4">Image Watermark</h4>

                            <!-- Current image preview -->
                            <div x-show="watermarkSettings.image_exists" class="mb-4">
                                <div class="text-sm text-dark-400 mb-2">Current watermark image:</div>
                                <div class="flex items-start gap-4">
                                    <div class="bg-dark-800 p-4 rounded-lg inline-block">
                                        <img :src="watermarkSettings.image_url" class="max-h-24 max-w-48" alt="Current watermark">
                                    </div>
                                    <div class="text-sm text-dark-400">
                                        <div x-text="watermarkSettings.image"></div>
                                        <button
                                            @click="deleteWatermarkImage()"
                                            class="text-red-400 hover:text-red-300 mt-2"
                                        >Delete image</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Upload new image -->
                            <div class="space-y-3">
                                <label class="block text-sm text-dark-400">Upload new watermark image (PNG with transparency recommended)</label>
                                <div class="flex gap-3">
                                    <input
                                        type="file"
                                        accept="image/png,image/jpeg,image/webp,image/svg+xml,image/gif"
                                        @change="watermarkImageFile = $event.target.files[0]"
                                        class="flex-1 px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg text-sm"
                                        :disabled="watermarkUploading"
                                    >
                                    <button
                                        @click="uploadWatermarkImage()"
                                        :disabled="!watermarkImageFile || watermarkUploading"
                                        class="px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-dark-700 disabled:text-dark-500 rounded-lg font-medium transition"
                                    >
                                        <span x-show="!watermarkUploading">Upload</span>
                                        <span x-show="watermarkUploading">Uploading...</span>
                                    </button>
                                </div>
                                <!-- Upload progress -->
                                <div x-show="watermarkUploading" class="w-full bg-dark-800 rounded-full h-2">
                                    <div class="bg-blue-500 h-2 rounded-full transition-all" :style="'width: ' + watermarkUploadProgress + '%'"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Text Watermark Section -->
                        <div class="border-t border-dark-800 pt-6">
                            <h4 class="font-medium mb-4">Text Watermark</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm text-dark-400 mb-1">Current text</label>
                                    <div class="px-4 py-2 bg-dark-800 rounded-lg text-dark-200" x-text="watermarkSettings.text || '(not set)'"></div>
                                </div>
                                <div>
                                    <label class="block text-sm text-dark-400 mb-1">Font size / Color</label>
                                    <div class="px-4 py-2 bg-dark-800 rounded-lg text-dark-200" x-text="watermarkSettings.text_size + 'px / ' + watermarkSettings.text_color"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Configuration Note -->
                        <div class="border-t border-dark-800 pt-6">
                            <div class="bg-dark-800 rounded-lg p-4">
                                <h4 class="font-medium mb-2 flex items-center gap-2">
                                    <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    Configuration
                                </h4>
                                <p class="text-sm text-dark-400 mb-3">
                                    Watermark settings are configured via environment variables. After uploading an image, set the following and restart services:
                                </p>
                                <pre class="bg-dark-950 rounded p-3 text-sm text-dark-300 overflow-x-auto">VLOG_WATERMARK_ENABLED=true
VLOG_WATERMARK_TYPE=image  # or "text"
VLOG_WATERMARK_IMAGE=<span x-text="watermarkSettings.image || 'watermark.png'"></span>
VLOG_WATERMARK_POSITION=bottom-right  # top-left, top-right, bottom-left, center
VLOG_WATERMARK_OPACITY=0.5  # 0.0 to 1.0
VLOG_WATERMARK_PADDING=16  # pixels from edge</pre>
                            </div>
                        </div>

                        <!-- Message display -->
                        <div x-show="watermarkMessage" class="mt-4">
                            <div :class="watermarkError ? 'bg-red-900/20 border-red-800 text-red-400' : 'bg-green-900/20 border-green-800 text-green-400'" class="border rounded-lg px-4 py-3 text-sm">
                                <span x-text="watermarkMessage"></span>
                            </div>
                        </div>
                    </div>

                    <!-- Not loaded state -->
                    <div x-show="!watermarkLoading && !watermarkSettings" class="text-center py-8 text-dark-400">
                        Failed to load watermark settings. <button @click="loadWatermarkSettings()" class="text-blue-400 hover:underline">Retry</button>
                    </div>
                </div>

                <!-- Custom Fields Panel -->
                <div x-show="settingsTab === 'custom_fields'" class="bg-dark-900 rounded-xl p-6">
                    <div class="flex items-center justify-between mb-6">
                        <div>
                            <h3 class="text-lg font-semibold">Custom Fields</h3>
                            <p class="text-dark-400 text-sm mt-1">Define custom metadata fields for videos. Fields can be global or category-specific.</p>
                        </div>
                        <button @click="openCreateFieldModal()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition text-sm">
                            Add Field
                        </button>
                    </div>

                    <!-- Loading state -->
                    <div x-show="customFieldsLoading" class="text-center py-8">
                        <div class="animate-spin rounded-full h-8 w-8 border-2 border-dark-700 border-t-blue-500 mx-auto"></div>
                    </div>

                    <!-- Message -->
                    <div x-show="customFieldMessage" class="mb-4">
                        <div :class="customFieldError ? 'bg-red-900/20 border-red-800 text-red-400' : 'bg-green-900/20 border-green-800 text-green-400'" class="border rounded-lg px-4 py-3 text-sm flex items-center justify-between">
                            <span x-text="customFieldMessage"></span>
                            <button @click="customFieldMessage = ''" class="text-dark-400 hover:text-white">&times;</button>
                        </div>
                    </div>

                    <!-- Fields List -->
                    <div x-show="!customFieldsLoading && customFields.length > 0" class="space-y-6">
                        <!-- Global Fields -->
                        <div x-show="customFields.filter(f => !f.category_id).length > 0">
                            <h4 class="text-sm font-medium text-dark-400 mb-3 uppercase tracking-wider">Global Fields</h4>
                            <div class="space-y-2">
                                <template x-for="field in customFields.filter(f => !f.category_id)" :key="field.id">
                                    <div class="flex items-center justify-between p-4 bg-dark-800 rounded-lg">
                                        <div class="flex-1">
                                            <div class="flex items-center gap-2">
                                                <span class="font-medium" x-text="field.name"></span>
                                                <span class="px-2 py-0.5 text-xs bg-dark-700 rounded" x-text="field.field_type"></span>
                                                <span x-show="field.required" class="px-2 py-0.5 text-xs bg-red-900/50 text-red-400 rounded">Required</span>
                                            </div>
                                            <div class="text-sm text-dark-400 mt-1" x-show="field.description" x-text="field.description"></div>
                                        </div>
                                        <div class="flex gap-2">
                                            <button @click="openEditFieldModal(field)" class="p-2 text-dark-400 hover:text-white hover:bg-dark-700 rounded-lg transition">
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                                            </button>
                                            <button @click="deleteCustomField(field)" class="p-2 text-dark-400 hover:text-red-400 hover:bg-dark-700 rounded-lg transition">
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                            </button>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>

                        <!-- Category-specific Fields -->
                        <template x-for="cat in categories" :key="cat.id">
                            <div x-show="customFields.filter(f => f.category_id === cat.id).length > 0">
                                <h4 class="text-sm font-medium text-dark-400 mb-3 uppercase tracking-wider" x-text="cat.name + ' Fields'"></h4>
                                <div class="space-y-2">
                                    <template x-for="field in customFields.filter(f => f.category_id === cat.id)" :key="field.id">
                                        <div class="flex items-center justify-between p-4 bg-dark-800 rounded-lg">
                                            <div class="flex-1">
                                                <div class="flex items-center gap-2">
                                                    <span class="font-medium" x-text="field.name"></span>
                                                    <span class="px-2 py-0.5 text-xs bg-dark-700 rounded" x-text="field.field_type"></span>
                                                    <span x-show="field.required" class="px-2 py-0.5 text-xs bg-red-900/50 text-red-400 rounded">Required</span>
                                                </div>
                                                <div class="text-sm text-dark-400 mt-1" x-show="field.description" x-text="field.description"></div>
                                            </div>
                                            <div class="flex gap-2">
                                                <button @click="openEditFieldModal(field)" class="p-2 text-dark-400 hover:text-white hover:bg-dark-700 rounded-lg transition">
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                                                </button>
                                                <button @click="deleteCustomField(field)" class="p-2 text-dark-400 hover:text-red-400 hover:bg-dark-700 rounded-lg transition">
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                                </button>
                                            </div>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </template>
                    </div>

                    <!-- Empty state -->
                    <div x-show="!customFieldsLoading && customFields.length === 0" class="text-center py-12">
                        <div class="text-dark-400 mb-4">No custom fields defined yet.</div>
                        <button @click="openCreateFieldModal()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition text-sm">
                            Create Your First Field
                        </button>
                    </div>
                </div>

                <!-- Custom Field Create/Edit Modal -->
                <div x-show="customFieldModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm" @keydown.escape.window="customFieldModal = false">
                    <div class="bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4 max-h-[90vh] overflow-y-auto" @click.stop>
                        <h3 class="text-lg font-semibold mb-4" x-text="customFieldEditing ? 'Edit Custom Field' : 'Create Custom Field'"></h3>

                        <form @submit.prevent="saveCustomField" class="space-y-4">
                            <!-- Name -->
                            <div>
                                <label class="block text-sm font-medium mb-2">Name <span class="text-red-400">*</span></label>
                                <input type="text" x-model="customFieldForm.name" required maxlength="100"
                                    class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none"
                                    placeholder="e.g., Difficulty Level">
                            </div>

                            <!-- Type (disabled when editing) -->
                            <div>
                                <label class="block text-sm font-medium mb-2">Field Type <span class="text-red-400">*</span></label>
                                <select x-model="customFieldForm.field_type" :disabled="customFieldEditing"
                                    class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none disabled:opacity-50">
                                    <option value="text">Text</option>
                                    <option value="number">Number</option>
                                    <option value="date">Date</option>
                                    <option value="url">URL</option>
                                    <option value="select">Select (Single Choice)</option>
                                    <option value="multi_select">Multi-Select (Multiple Choices)</option>
                                </select>
                                <p x-show="customFieldEditing" class="text-xs text-dark-400 mt-1">Field type cannot be changed after creation.</p>
                            </div>

                            <!-- Options (for select/multi_select) -->
                            <div x-show="customFieldForm.field_type === 'select' || customFieldForm.field_type === 'multi_select'">
                                <label class="block text-sm font-medium mb-2">Options <span class="text-red-400">*</span></label>
                                <div class="space-y-2">
                                    <template x-for="(opt, idx) in customFieldForm.options" :key="idx">
                                        <div class="flex gap-2">
                                            <input type="text" x-model="customFieldForm.options[idx]"
                                                class="flex-1 px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:border-blue-500 outline-none"
                                                placeholder="Option value">
                                            <button type="button" @click="customFieldForm.options.splice(idx, 1)"
                                                class="p-2 text-dark-400 hover:text-red-400 hover:bg-dark-700 rounded-lg">
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                                            </button>
                                        </div>
                                    </template>
                                    <button type="button" @click="customFieldForm.options.push('')"
                                        class="w-full py-2 border border-dashed border-dark-600 text-dark-400 hover:border-dark-500 hover:text-dark-300 rounded-lg text-sm">
                                        + Add Option
                                    </button>
                                </div>
                            </div>

                            <!-- Category (disabled when editing) -->
                            <div>
                                <label class="block text-sm font-medium mb-2">Scope</label>
                                <select x-model="customFieldForm.category_id" :disabled="customFieldEditing"
                                    class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none disabled:opacity-50">
                                    <option :value="null">Global (applies to all videos)</option>
                                    <template x-for="cat in categories" :key="cat.id">
                                        <option :value="cat.id" x-text="cat.name + ' only'"></option>
                                    </template>
                                </select>
                                <p x-show="customFieldEditing" class="text-xs text-dark-400 mt-1">Scope cannot be changed after creation.</p>
                            </div>

                            <!-- Required -->
                            <div class="flex items-center gap-3">
                                <input type="checkbox" x-model="customFieldForm.required" id="field-required"
                                    class="w-4 h-4 rounded border-dark-600 bg-dark-800 text-blue-600 focus:ring-blue-500">
                                <label for="field-required" class="text-sm">Required field</label>
                            </div>

                            <!-- Description -->
                            <div>
                                <label class="block text-sm font-medium mb-2">Help Text</label>
                                <textarea x-model="customFieldForm.description" rows="2" maxlength="500"
                                    class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none"
                                    placeholder="Optional description shown to users when editing videos"></textarea>
                            </div>

                            <!-- Buttons -->
                            <div class="flex justify-end gap-3 pt-4">
                                <button type="button" @click="customFieldModal = false" class="px-4 py-2 bg-dark-800 hover:bg-dark-700 rounded-lg transition">
                                    Cancel
                                </button>
                                <button type="submit" :disabled="customFieldSaving"
                                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:opacity-50 rounded-lg font-medium transition">
                                    <span x-show="!customFieldSaving" x-text="customFieldEditing ? 'Save Changes' : 'Create Field'"></span>
                                    <span x-show="customFieldSaving">Saving...</span>
                                </button>
                            </div>
                        </form>
                    </div>
                </div>

                <!-- Dynamic Category Settings Panels -->
                <template x-for="category in settingsCategories" :key="category">
                    <div x-show="settingsTab === category" class="bg-dark-900 rounded-xl p-6">
                        <div class="flex items-center justify-between mb-6">
                            <h3 class="text-lg font-semibold capitalize" x-text="category.replace(/_/g, ' ') + ' Settings'"></h3>
                            <div class="flex gap-2">
                                <button
                                    @click="resetCategorySettings(category)"
                                    :disabled="!hasModifiedSettings(category)"
                                    class="px-3 py-1.5 text-sm bg-dark-800 hover:bg-dark-700 disabled:opacity-50 disabled:cursor-not-allowed border border-dark-700 rounded-lg transition"
                                >Reset</button>
                                <button
                                    @click="saveAllCategorySettings(category)"
                                    :disabled="!hasModifiedSettings(category) || settingsSaving"
                                    class="px-4 py-1.5 text-sm bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg font-medium transition"
                                >
                                    <span x-show="!settingsSaving">Save Changes</span>
                                    <span x-show="settingsSaving">Saving...</span>
                                </button>
                            </div>
                        </div>

                        <!-- Loading state -->
                        <div x-show="settingsLoading || settingsLoadingCategory === category" class="text-center py-8">
                            <div class="animate-spin rounded-full h-8 w-8 border-2 border-dark-700 border-t-blue-500 mx-auto"></div>
                        </div>

                        <!-- Settings list -->
                        <div x-show="!settingsLoading && settingsByCategory[category]" class="space-y-4">
                            <!-- Empty state -->
                            <div x-show="!settingsByCategory[category] || settingsByCategory[category].length === 0" class="text-center py-8 text-dark-400">
                                No settings configured for this category yet.
                            </div>

                            <!-- Settings form -->
                            <template x-for="(setting, index) in settingsByCategory[category] || []" :key="setting.key">
                                <div class="p-4 bg-dark-800 rounded-lg">
                                    <div class="flex items-start justify-between gap-4">
                                        <div class="flex-1 min-w-0">
                                            <label class="block font-medium mb-1" x-text="setting.key.split('.').pop().replace(/_/g, ' ')"></label>
                                            <div class="text-sm text-dark-400 mb-3" x-text="setting.description || 'No description'"></div>

                                            <!-- Boolean toggle -->
                                            <template x-if="setting.value_type === 'boolean'">
                                                <label class="relative inline-flex items-center cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        :checked="setting.value"
                                                        @change="setting.value = $event.target.checked; markSettingModified(category, setting.key, setting.value)"
                                                        class="sr-only peer"
                                                    >
                                                    <div class="w-11 h-6 bg-dark-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                                    <span class="ml-3 text-sm" x-text="setting.value ? 'Enabled' : 'Disabled'"></span>
                                                </label>
                                            </template>

                                            <!-- Integer input -->
                                            <template x-if="setting.value_type === 'integer'">
                                                <input
                                                    type="number"
                                                    :value="setting.value"
                                                    @input="setting.value = parseInt($event.target.value, 10); markSettingModified(category, setting.key, setting.value)"
                                                    :min="setting.constraints?.min"
                                                    :max="setting.constraints?.max"
                                                    class="w-full max-w-xs px-4 py-2 bg-dark-900 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                                >
                                            </template>

                                            <!-- Float input -->
                                            <template x-if="setting.value_type === 'float'">
                                                <input
                                                    type="number"
                                                    step="0.01"
                                                    :value="setting.value"
                                                    @input="setting.value = parseFloat($event.target.value); markSettingModified(category, setting.key, setting.value)"
                                                    :min="setting.constraints?.min"
                                                    :max="setting.constraints?.max"
                                                    class="w-full max-w-xs px-4 py-2 bg-dark-900 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                                >
                                            </template>

                                            <!-- Enum select -->
                                            <template x-if="setting.value_type === 'enum'">
                                                <select
                                                    :value="setting.value"
                                                    @change="setting.value = $event.target.value; markSettingModified(category, setting.key, setting.value)"
                                                    class="w-full max-w-xs px-4 py-2 bg-dark-900 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                                >
                                                    <template x-for="opt in setting.constraints?.enum_values || []" :key="opt">
                                                        <option :value="opt" :selected="setting.value === opt" x-text="opt"></option>
                                                    </template>
                                                </select>
                                            </template>

                                            <!-- String input -->
                                            <template x-if="setting.value_type === 'string'">
                                                <input
                                                    type="text"
                                                    :value="setting.value"
                                                    @input="setting.value = $event.target.value; markSettingModified(category, setting.key, setting.value)"
                                                    :minlength="setting.constraints?.min_length"
                                                    :maxlength="setting.constraints?.max_length"
                                                    :pattern="setting.constraints?.pattern"
                                                    class="w-full max-w-md px-4 py-2 bg-dark-900 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                                                >
                                            </template>

                                            <!-- JSON textarea -->
                                            <template x-if="setting.value_type === 'json'">
                                                <textarea
                                                    :value="JSON.stringify(setting.value, null, 2)"
                                                    @input="try { setting.value = JSON.parse($event.target.value); markSettingModified(category, setting.key, setting.value); } catch(e) {}"
                                                    rows="4"
                                                    class="w-full px-4 py-2 bg-dark-900 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500 font-mono text-sm"
                                                ></textarea>
                                            </template>

                                            <!-- Constraints info -->
                                            <div x-show="setting.constraints" class="mt-2 text-xs text-dark-500">
                                                <span x-show="setting.constraints?.min !== undefined" x-text="'Min: ' + setting.constraints?.min + ' '"></span>
                                                <span x-show="setting.constraints?.max !== undefined" x-text="'Max: ' + setting.constraints?.max"></span>
                                            </div>
                                        </div>

                                        <!-- Modified indicator -->
                                        <div x-show="settingsModified[category]?.[setting.key] !== undefined" class="text-yellow-500" title="Modified">
                                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                                <circle cx="10" cy="10" r="5"></circle>
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </template>

                <!-- No settings loaded state -->
                <div x-show="!settingsLoading && settingsCategories.length === 0 && settingsTab !== 'watermark'" class="bg-dark-900 rounded-xl p-6 text-center text-dark-400">
                    <p class="mb-4">No database settings configured yet.</p>
                    <p class="text-sm">Settings will appear here after running the migration and seeding default values.</p>
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Video Modal -->
    <div x-show="editModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="editModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-semibold mb-4">Edit Video</h3>
            <form @submit.prevent="saveVideo" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Title</label>
                    <input
                        type="text"
                        x-model="editTitle"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                        required
                    >
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Description</label>
                    <textarea
                        x-model="editDescription"
                        rows="4"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    ></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Category</label>
                    <select
                        x-model="editCategory"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                        <option value="0">No category</option>
                        <template x-for="cat in categories" :key="cat.id">
                            <option :value="cat.id" x-text="cat.name"></option>
                        </template>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Publish Date</label>
                    <input
                        type="datetime-local"
                        x-model="editPublishedAt"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                    <p class="text-xs text-gray-500 mt-1">Leave empty to use current date when video becomes ready</p>
                </div>

                <!-- Custom Fields Section -->
                <template x-if="getApplicableCustomFields().length > 0">
                    <div class="border-t border-dark-700 pt-4 mt-4">
                        <h4 class="text-sm font-medium text-dark-400 mb-3">Custom Fields</h4>
                        <div class="space-y-3">
                            <template x-for="field in getApplicableCustomFields()" :key="field.id">
                                <div>
                                    <label class="block text-sm font-medium mb-1">
                                        <span x-text="field.name"></span>
                                        <span x-show="field.required" class="text-red-400">*</span>
                                    </label>
                                    <p x-show="field.description" class="text-xs text-dark-400 mb-1" x-text="field.description"></p>

                                    <!-- Text field -->
                                    <template x-if="field.field_type === 'text'">
                                        <input
                                            type="text"
                                            :value="editCustomFieldValues[field.id] || ''"
                                            @input="editCustomFieldValues[field.id] = $event.target.value"
                                            :required="field.required"
                                            :minlength="field.constraints?.min_length"
                                            :maxlength="field.constraints?.max_length"
                                            :pattern="field.constraints?.pattern"
                                            class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500 text-sm"
                                        >
                                    </template>

                                    <!-- Number field -->
                                    <template x-if="field.field_type === 'number'">
                                        <input
                                            type="number"
                                            :value="editCustomFieldValues[field.id] ?? ''"
                                            @input="editCustomFieldValues[field.id] = $event.target.value ? parseFloat($event.target.value) : null"
                                            :required="field.required"
                                            :min="field.constraints?.min"
                                            :max="field.constraints?.max"
                                            :step="field.constraints?.step || 'any'"
                                            class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500 text-sm"
                                        >
                                    </template>

                                    <!-- Date field -->
                                    <template x-if="field.field_type === 'date'">
                                        <input
                                            type="date"
                                            :value="editCustomFieldValues[field.id] || ''"
                                            @input="editCustomFieldValues[field.id] = $event.target.value"
                                            :required="field.required"
                                            :min="field.constraints?.min_date"
                                            :max="field.constraints?.max_date"
                                            class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500 text-sm"
                                        >
                                    </template>

                                    <!-- URL field -->
                                    <template x-if="field.field_type === 'url'">
                                        <input
                                            type="url"
                                            :value="editCustomFieldValues[field.id] || ''"
                                            @input="editCustomFieldValues[field.id] = $event.target.value"
                                            :required="field.required"
                                            placeholder="https://..."
                                            class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500 text-sm"
                                        >
                                    </template>

                                    <!-- Select field -->
                                    <template x-if="field.field_type === 'select'">
                                        <select
                                            :value="editCustomFieldValues[field.id] || ''"
                                            @change="editCustomFieldValues[field.id] = $event.target.value"
                                            :required="field.required"
                                            class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500 text-sm"
                                        >
                                            <option value="">-- Select --</option>
                                            <template x-for="opt in field.options" :key="opt">
                                                <option :value="opt" x-text="opt"></option>
                                            </template>
                                        </select>
                                    </template>

                                    <!-- Multi-select field -->
                                    <template x-if="field.field_type === 'multi_select'">
                                        <div class="space-y-1">
                                            <template x-for="opt in field.options" :key="opt">
                                                <label class="flex items-center gap-2 text-sm cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        :checked="(editCustomFieldValues[field.id] || []).includes(opt)"
                                                        @change="toggleMultiSelectOption(field.id, opt)"
                                                        class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"
                                                    >
                                                    <span x-text="opt"></span>
                                                </label>
                                            </template>
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </div>
                </template>

                <div class="flex gap-3 pt-2">
                    <button
                        type="button"
                        @click="editModal = false"
                        class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 rounded-lg font-medium transition"
                    >Cancel</button>
                    <button
                        type="submit"
                        class="flex-1 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition"
                    >Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Re-upload Video Modal -->
    <div x-show="reuploadModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="reuploadModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-semibold mb-2">Re-upload Video</h3>
            <p class="text-dark-400 text-sm mb-4">
                Replace the video file for "<span x-text="reuploadTitle" class="text-white"></span>".
                This will delete all transcoded files and re-process the video.
                Metadata (title, description, category, dates) will be preserved.
            </p>
            <form @submit.prevent="reuploadVideo" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">New Video File</label>
                    <input
                        type="file"
                        accept="video/*"
                        @change="reuploadFile = $event.target.files[0]"
                        class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-purple-500"
                        required
                    >
                </div>

                <!-- Re-upload Progress -->
                <div x-show="reuploadProgress >= 0" class="space-y-2">
                    <div class="flex justify-between text-sm">
                        <span>Uploading...</span>
                        <span x-text="reuploadProgress + '%'"></span>
                    </div>
                    <div class="w-full bg-dark-700 rounded-full h-2">
                        <div
                            class="bg-purple-500 h-2 rounded-full transition-all"
                            :style="'width: ' + reuploadProgress + '%'"
                        ></div>
                    </div>
                </div>

                <div x-show="reuploadMessage" :class="reuploadError ? 'text-red-400' : 'text-green-400'" class="text-sm" x-text="reuploadMessage"></div>

                <div class="flex gap-3 pt-2">
                    <button
                        type="button"
                        @click="reuploadModal = false"
                        :disabled="reuploading"
                        class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                    >Cancel</button>
                    <button
                        type="submit"
                        :disabled="reuploading"
                        class="flex-1 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!reuploading">Re-upload</span>
                        <span x-show="reuploading">Uploading...</span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Re-transcode Video Modal -->
    <div x-show="retranscodeModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="retranscodeModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-semibold mb-2">Re-transcode Video</h3>
            <p class="text-dark-400 text-sm mb-4">
                Select qualities to re-transcode for "<span x-text="retranscodeTitle" class="text-white"></span>".
                Selected quality files will be deleted and regenerated from the source.
            </p>

            <div class="space-y-4">
                <!-- Select All / Deselect All buttons -->
                <div class="flex gap-2">
                    <button
                        @click="selectAllQualities"
                        class="px-3 py-1 text-sm bg-dark-700 hover:bg-dark-600 rounded transition"
                    >Select All</button>
                    <button
                        @click="deselectAllQualities"
                        class="px-3 py-1 text-sm bg-dark-700 hover:bg-dark-600 rounded transition"
                    >Deselect All</button>
                </div>

                <!-- Quality checkboxes -->
                <div class="space-y-2 max-h-64 overflow-y-auto">
                    <template x-for="quality in retranscodeAvailable" :key="quality">
                        <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                            <input
                                type="checkbox"
                                :checked="retranscodeSelected.includes(quality)"
                                @change="toggleRetranscodeQuality(quality)"
                                class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                            >
                            <span class="flex-1">
                                <span class="font-medium" x-text="quality"></span>
                            </span>
                            <span
                                :class="{
                                    'text-green-400': getQualityStatus(quality) === 'completed',
                                    'text-dark-500': getQualityStatus(quality) === 'not transcoded'
                                }"
                                class="text-xs"
                                x-text="getQualityStatus(quality)"
                            ></span>
                        </label>
                    </template>
                </div>

                <!-- No qualities message -->
                <div x-show="retranscodeAvailable.length === 0" class="text-dark-400 text-center py-4">
                    No qualities available for this video.
                </div>

                <!-- Status message -->
                <div x-show="retranscodeMessage" :class="retranscodeError ? 'text-red-400' : 'text-green-400'" class="text-sm" x-text="retranscodeMessage"></div>

                <!-- Action buttons -->
                <div class="flex gap-3 pt-2">
                    <button
                        type="button"
                        @click="retranscodeModal = false"
                        :disabled="retranscoding"
                        class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                    >Cancel</button>
                    <button
                        @click="submitRetranscode()"
                        :disabled="retranscoding || retranscodeSelected.length === 0"
                        class="flex-1 py-2 bg-cyan-600 hover:bg-cyan-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!retranscoding">Re-transcode (<span x-text="retranscodeSelected.length"></span>)</span>
                        <span x-show="retranscoding">Processing...</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Thumbnail Selection Modal -->
    <div x-show="thumbnailModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="thumbnailModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-3xl mx-4 max-h-[90vh] overflow-y-auto">
            <h3 class="text-xl font-semibold mb-2">Select Thumbnail</h3>
            <p class="text-dark-400 text-sm mb-4">
                Choose a thumbnail for "<span x-text="thumbnailVideoTitle" class="text-white"></span>"
            </p>

            <!-- Current Thumbnail -->
            <div class="mb-6">
                <h4 class="text-sm font-medium mb-2 text-dark-300">Current Thumbnail</h4>
                <div class="flex items-center gap-4">
                    <div class="w-40 aspect-video bg-dark-800 rounded overflow-hidden">
                        <img :src="'/videos/' + thumbnailVideoSlug + '/thumbnail.jpg?t=' + thumbnailCacheBust"
                             class="w-full h-full object-cover"
                             @error="$el.style.display='none'">
                    </div>
                    <div class="text-sm text-dark-400">
                        <span>Source:</span>
                        <span class="text-white capitalize" x-text="thumbnailSource"></span>
                    </div>
                </div>
            </div>

            <!-- Frame Selection -->
            <div class="mb-6">
                <div class="flex justify-between items-center mb-3">
                    <h4 class="text-sm font-medium text-dark-300">Select from Video Frames</h4>
                    <button
                        @click="generateThumbnailFrames()"
                        :disabled="thumbnailLoading"
                        class="px-3 py-1 text-sm bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded transition"
                    >
                        <span x-show="!thumbnailLoading">Generate Frames</span>
                        <span x-show="thumbnailLoading">Generating...</span>
                    </button>
                </div>
                <div x-show="thumbnailFrames.length > 0" class="grid grid-cols-5 gap-2" style="grid-template-columns: repeat(5, minmax(0, 1fr));">
                    <template x-for="frame in thumbnailFrames" :key="frame.index">
                        <button
                            @click="selectThumbnailFrame(frame.timestamp)"
                            :disabled="thumbnailLoading"
                            class="bg-dark-800 rounded overflow-hidden hover:ring-2 hover:ring-cyan-500 transition"
                            style="min-width: 0;"
                        >
                            <div style="position: relative; padding-bottom: 56.25%; overflow: hidden;">
                                <img :src="frame.url + '?t=' + Date.now()" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
                            </div>
                            <div class="bg-black/70 text-xs text-center py-1" x-text="formatDuration(frame.timestamp)"></div>
                        </button>
                    </template>
                </div>
                <div x-show="thumbnailFrames.length === 0" class="text-dark-500 text-sm py-4 text-center bg-dark-800 rounded">
                    Click "Generate Frames" to see frame options from the video.
                </div>
            </div>

            <!-- Custom Upload -->
            <div class="mb-6">
                <h4 class="text-sm font-medium mb-2 text-dark-300">Upload Custom Thumbnail</h4>
                <div class="flex items-center gap-3">
                    <input
                        type="file"
                        accept="image/jpeg,image/png,image/webp"
                        @change="thumbnailUploadFile = $event.target.files[0]"
                        class="flex-1 px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg text-sm file:mr-3 file:py-1 file:px-3 file:rounded file:border-0 file:bg-dark-700 file:text-white"
                    >
                    <button
                        @click="uploadCustomThumbnail()"
                        :disabled="!thumbnailUploadFile || thumbnailUploading"
                        class="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 disabled:bg-dark-700 disabled:opacity-50 rounded-lg text-sm font-medium transition"
                    >
                        <span x-show="!thumbnailUploading">Upload</span>
                        <span x-show="thumbnailUploading">Uploading...</span>
                    </button>
                </div>
                <p class="text-xs text-dark-500 mt-2">Accepts JPEG, PNG, or WebP (max 10MB). Will be resized to 640px width.</p>
            </div>

            <!-- Revert Option -->
            <div class="mb-6" x-show="thumbnailSource !== 'auto'">
                <button
                    @click="revertThumbnail()"
                    :disabled="thumbnailLoading"
                    class="text-sm text-yellow-400 hover:text-yellow-300 disabled:opacity-50"
                >Revert to auto-generated thumbnail</button>
            </div>

            <!-- Messages -->
            <div x-show="thumbnailMessage" :class="thumbnailError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="thumbnailMessage"></div>

            <!-- Close Button -->
            <div class="flex justify-end">
                <button
                    @click="thumbnailModal = false"
                    class="px-4 py-2 bg-dark-700 hover:bg-dark-600 rounded-lg font-medium transition"
                >Close</button>
            </div>
        </div>
    </div>

    <!-- Bulk Delete Modal -->
    <div x-show="bulkDeleteModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="bulkDeleteModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-semibold mb-4">Delete Videos</h3>
            <p class="text-dark-300 mb-4">
                You are about to delete <span class="text-white font-semibold" x-text="selectedVideos.length"></span> video(s).
            </p>
            <div class="mb-4">
                <label class="flex items-center gap-3 cursor-pointer">
                    <input
                        type="checkbox"
                        x-model="bulkDeletePermanent"
                        class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-red-500 focus:ring-red-500 focus:ring-offset-0"
                    >
                    <span class="text-dark-300">Permanently delete (cannot be undone)</span>
                </label>
            </div>
            <div x-show="bulkOpMessage" :class="bulkOpError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="bulkOpMessage"></div>
            <div class="flex gap-3">
                <button
                    @click="bulkDeleteModal = false"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                >Cancel</button>
                <button
                    @click="executeBulkDelete"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-red-600 hover:bg-red-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                >
                    <span x-show="!bulkOpLoading">Delete</span>
                    <span x-show="bulkOpLoading">Deleting...</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Bulk Update Modal -->
    <div x-show="bulkUpdateModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="bulkUpdateModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-semibold mb-4">Update Videos</h3>
            <p class="text-dark-300 mb-4">
                Update <span class="text-white font-semibold" x-text="selectedVideos.length"></span> video(s) with the following settings:
            </p>
            <div class="space-y-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Category</label>
                    <select
                        x-model="bulkUpdateCategory"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                        <option value="">-- Don't change --</option>
                        <option value="0">Remove category</option>
                        <template x-for="cat in categories" :key="cat.id">
                            <option :value="cat.id" x-text="cat.name"></option>
                        </template>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Published Date</label>
                    <input
                        type="datetime-local"
                        x-model="bulkUpdatePublishedAt"
                        class="w-full px-4 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                    >
                    <div class="mt-2">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input
                                type="checkbox"
                                x-model="bulkUpdateUnpublish"
                                class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0"
                            >
                            <span class="text-dark-400 text-sm">Unpublish (remove published date)</span>
                        </label>
                    </div>
                </div>
            </div>
            <div x-show="bulkOpMessage" :class="bulkOpError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="bulkOpMessage"></div>
            <div class="flex gap-3">
                <button
                    @click="bulkUpdateModal = false"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                >Cancel</button>
                <button
                    @click="executeBulkUpdate"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                >
                    <span x-show="!bulkOpLoading">Update</span>
                    <span x-show="bulkOpLoading">Updating...</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Bulk Retranscode Modal -->
    <div x-show="bulkRetranscodeModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="bulkRetranscodeModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-semibold mb-4">Re-transcode Videos</h3>
            <p class="text-dark-300 mb-4">
                Queue <span class="text-white font-semibold" x-text="selectedVideos.length"></span> video(s) for re-transcoding.
            </p>
            <div class="space-y-2 mb-4">
                <label class="block text-sm font-medium mb-2">Qualities to re-transcode</label>
                <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                    <input
                        type="radio"
                        name="bulkRetranscodeQuality"
                        value="all"
                        x-model="bulkRetranscodeQuality"
                        class="w-4 h-4 border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                    >
                    <span>All qualities (full re-encode)</span>
                </label>
                <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                    <input
                        type="radio"
                        name="bulkRetranscodeQuality"
                        value="1080p"
                        x-model="bulkRetranscodeQuality"
                        class="w-4 h-4 border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                    >
                    <span>1080p only</span>
                </label>
                <label class="flex items-center gap-3 p-3 bg-dark-800 rounded-lg cursor-pointer hover:bg-dark-700 transition">
                    <input
                        type="radio"
                        name="bulkRetranscodeQuality"
                        value="720p"
                        x-model="bulkRetranscodeQuality"
                        class="w-4 h-4 border-dark-600 bg-dark-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0"
                    >
                    <span>720p only</span>
                </label>
            </div>
            <div x-show="bulkOpMessage" :class="bulkOpError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="bulkOpMessage"></div>
            <div class="flex gap-3">
                <button
                    @click="bulkRetranscodeModal = false"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                >Cancel</button>
                <button
                    @click="executeBulkRetranscode"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-cyan-600 hover:bg-cyan-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                >
                    <span x-show="!bulkOpLoading">Re-transcode</span>
                    <span x-show="bulkOpLoading">Queueing...</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Bulk Custom Fields Modal -->
    <div x-show="bulkCustomFieldsModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/70" @click="bulkCustomFieldsModal = false"></div>
        <div class="relative bg-dark-900 rounded-xl p-6 w-full max-w-lg mx-4 max-h-[90vh] overflow-y-auto">
            <h3 class="text-xl font-semibold mb-4">Set Custom Fields</h3>
            <p class="text-dark-300 mb-4">
                Set custom field values for <span class="text-white font-semibold" x-text="selectedVideos.length"></span> video(s).
                Only global fields are available for bulk updates.
            </p>
            <div class="space-y-4 mb-4">
                <template x-for="field in customFields.filter(f => f.category_id === null)" :key="field.id">
                    <div>
                        <label class="block text-sm font-medium mb-1">
                            <span x-text="field.name"></span>
                        </label>
                        <p x-show="field.description" class="text-xs text-dark-400 mb-1" x-text="field.description"></p>

                        <!-- Text field -->
                        <template x-if="field.field_type === 'text'">
                            <input
                                type="text"
                                :value="bulkCustomFieldValues[field.id] || ''"
                                @input="bulkCustomFieldValues[field.id] = $event.target.value"
                                :minlength="field.constraints?.min_length"
                                :maxlength="field.constraints?.max_length"
                                :pattern="field.constraints?.pattern"
                                placeholder="Leave empty to skip"
                                class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-purple-500 text-sm"
                            >
                        </template>

                        <!-- Number field -->
                        <template x-if="field.field_type === 'number'">
                            <input
                                type="number"
                                :value="bulkCustomFieldValues[field.id] ?? ''"
                                @input="bulkCustomFieldValues[field.id] = $event.target.value ? parseFloat($event.target.value) : null"
                                :min="field.constraints?.min"
                                :max="field.constraints?.max"
                                :step="field.constraints?.step || 'any'"
                                placeholder="Leave empty to skip"
                                class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-purple-500 text-sm"
                            >
                        </template>

                        <!-- Date field -->
                        <template x-if="field.field_type === 'date'">
                            <input
                                type="date"
                                :value="bulkCustomFieldValues[field.id] || ''"
                                @input="bulkCustomFieldValues[field.id] = $event.target.value"
                                :min="field.constraints?.min_date"
                                :max="field.constraints?.max_date"
                                class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-purple-500 text-sm"
                            >
                        </template>

                        <!-- URL field -->
                        <template x-if="field.field_type === 'url'">
                            <input
                                type="url"
                                :value="bulkCustomFieldValues[field.id] || ''"
                                @input="bulkCustomFieldValues[field.id] = $event.target.value"
                                placeholder="https://..."
                                class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-purple-500 text-sm"
                            >
                        </template>

                        <!-- Select field -->
                        <template x-if="field.field_type === 'select'">
                            <select
                                :value="bulkCustomFieldValues[field.id] || ''"
                                @change="bulkCustomFieldValues[field.id] = $event.target.value"
                                class="w-full px-3 py-2 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-purple-500 text-sm"
                            >
                                <option value="">-- Don't change --</option>
                                <template x-for="opt in field.options" :key="opt">
                                    <option :value="opt" x-text="opt"></option>
                                </template>
                            </select>
                        </template>

                        <!-- Multi-select field -->
                        <template x-if="field.field_type === 'multi_select'">
                            <div class="space-y-1">
                                <template x-for="opt in field.options" :key="opt">
                                    <label class="flex items-center gap-2 text-sm cursor-pointer">
                                        <input
                                            type="checkbox"
                                            :checked="(bulkCustomFieldValues[field.id] || []).includes(opt)"
                                            @change="toggleBulkMultiSelectOption(field.id, opt)"
                                            class="w-4 h-4 rounded border-dark-600 bg-dark-700 text-purple-500 focus:ring-purple-500 focus:ring-offset-0"
                                        >
                                        <span x-text="opt"></span>
                                    </label>
                                </template>
                            </div>
                        </template>
                    </div>
                </template>

                <div x-show="customFields.filter(f => f.category_id === null).length === 0" class="text-dark-400 text-center py-4">
                    No global custom fields defined. Create custom fields in Settings first.
                </div>
            </div>
            <div x-show="bulkOpMessage" :class="bulkOpError ? 'text-red-400' : 'text-green-400'" class="text-sm mb-4" x-text="bulkOpMessage"></div>
            <div class="flex gap-3">
                <button
                    @click="bulkCustomFieldsModal = false"
                    :disabled="bulkOpLoading"
                    class="flex-1 py-2 bg-dark-700 hover:bg-dark-600 disabled:opacity-50 rounded-lg font-medium transition"
                >Cancel</button>
                <button
                    @click="executeBulkCustomFields"
                    :disabled="bulkOpLoading || customFields.filter(f => f.category_id === null).length === 0"
                    class="flex-1 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                >
                    <span x-show="!bulkOpLoading">Apply</span>
                    <span x-show="bulkOpLoading">Applying...</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div x-show="showAuthModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center bg-black/70">
        <div class="bg-dark-900 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl">
            <h3 class="text-xl font-semibold mb-4">Authentication Required</h3>
            <p class="text-dark-400 mb-4">This Admin API requires authentication. Enter your admin secret to continue.</p>
            <form @submit.prevent="submitAuth">
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Admin Secret</label>
                    <input
                        type="password"
                        x-model="authSecretInput"
                        x-ref="authInput"
                        class="w-full px-4 py-3 bg-dark-800 border border-dark-700 rounded-lg focus:outline-none focus:border-blue-500"
                        placeholder="Enter VLOG_ADMIN_API_SECRET"
                        required
                        autocomplete="new-password"
                    >
                </div>
                <div x-show="authError" class="text-red-400 text-sm mb-4" x-text="authError"></div>
                <div class="flex gap-3">
                    <button
                        type="submit"
                        :disabled="authLoading"
                        class="flex-1 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-dark-700 rounded-lg font-medium transition"
                    >
                        <span x-show="!authLoading">Authenticate</span>
                        <span x-show="authLoading">Checking...</span>
                    </button>
                </div>
            </form>
            <p class="text-dark-500 text-xs mt-4 text-center">Session is managed securely on the server</p>
        </div>
    </div>

    <script>
        function admin() {
            return {
                // Authentication state
                // Note: Auth is now managed via HTTP-only cookies set by the server
                // See: https://github.com/filthyrake/vlog/issues/324
                isAuthenticated: false,
                showAuthModal: false,
                authSecretInput: '',
                authError: '',
                authLoading: false,
                authRequired: false,
                csrfToken: '',  // CSRF token for state-changing requests

                tab: 'videos',
                videos: [],
                categories: [],

                // Upload form
                uploadFile: null,
                uploadTitle: '',
                uploadDescription: '',
                uploadCategory: '',
                uploading: false,
                uploadProgress: -1,
                uploadMessage: '',
                uploadError: false,

                // Category form
                newCategoryName: '',
                newCategoryDesc: '',

                // Edit modal
                editModal: false,
                editVideoId: null,
                editTitle: '',
                editDescription: '',
                editCategory: 0,
                editPublishedAt: '',

                // Re-upload modal
                reuploadModal: false,
                reuploadVideoId: null,
                reuploadTitle: '',
                reuploadFile: null,
                reuploading: false,
                reuploadProgress: -1,
                reuploadMessage: '',
                reuploadError: false,

                // Re-transcode modal
                retranscodeModal: false,
                retranscodeVideoId: null,
                retranscodeTitle: '',
                retranscodeQualities: [],
                retranscodeAvailable: [],
                retranscodeExisting: [],
                retranscodeSelected: [],
                retranscoding: false,
                retranscodeMessage: '',
                retranscodeError: false,

                // Thumbnail selection modal
                thumbnailModal: false,
                thumbnailVideoId: null,
                thumbnailVideoSlug: '',
                thumbnailVideoTitle: '',
                thumbnailDuration: 0,
                thumbnailSource: 'auto',
                thumbnailFrames: [],
                thumbnailLoading: false,
                thumbnailUploading: false,
                thumbnailUploadFile: null,
                thumbnailCacheBust: Date.now(),
                thumbnailMessage: '',
                thumbnailError: false,

                // Analytics
                analyticsOverview: {},
                analyticsVideos: [],
                analyticsPeriod: 'all',

                // Workers
                workersList: [],
                workerStats: {},
                activeJobs: { jobs: [], total_count: 0, processing_count: 0, pending_count: 0 },

                // Transcode progress
                progressData: {},

                // SSE connections for real-time updates
                progressSSE: null,
                workersSSE: null,
                sseReconnectAttempts: 0,
                maxSseReconnectDelay: 30000,

                // Watermark settings
                watermarkSettings: {
                    enabled: false,
                    type: 'image',
                    position: 'bottom-right',
                    opacity: 0.5,
                    image: null,
                    image_exists: false,
                    image_url: null,
                    text: '',
                    text_size: 24,
                    text_color: '#ffffff'
                },
                watermarkLoading: false,
                watermarkImageFile: null,
                watermarkUploading: false,
                watermarkUploadProgress: 0,
                watermarkMessage: '',
                watermarkError: false,

                // Database-backed settings (Phase 2)
                settingsTab: 'watermark',  // Active settings sub-tab
                settingsCategories: [],     // List of category names
                settingsByCategory: {},     // Settings grouped by category
                settingsLoading: false,
                settingsLoadingCategory: null,
                settingsSaving: false,
                settingsMessage: '',
                settingsError: false,
                settingsModified: {},       // Track modified values per category
                settingsOriginal: {},       // Original values for reset

                // Custom Fields (Issue #224)
                customFields: [],                   // All custom field definitions
                customFieldsLoading: false,
                customFieldModal: false,            // Create/edit modal open
                customFieldEditing: null,           // Field being edited (null = create)
                customFieldForm: {                  // Form state
                    name: '',
                    field_type: 'text',
                    options: [],
                    required: false,
                    category_id: null,
                    position: 0,
                    description: '',
                },
                customFieldSaving: false,
                customFieldMessage: '',
                customFieldError: false,
                editCustomFields: [],               // Fields applicable to current video
                editCustomFieldValues: {},          // field_id -> value map

                // Bulk operations
                selectedVideos: [],
                bulkDeleteModal: false,
                bulkDeletePermanent: false,
                bulkUpdateModal: false,
                bulkUpdateCategory: '',
                bulkUpdatePublishedAt: '',
                bulkUpdateUnpublish: false,
                bulkRetranscodeModal: false,
                bulkRetranscodeQuality: 'all',
                bulkCustomFieldsModal: false,
                bulkCustomFieldValues: {},
                bulkOpLoading: false,
                bulkOpMessage: '',
                bulkOpError: false,

                // Fetch CSRF token from server (call after authentication)
                async fetchCsrfToken() {
                    try {
                        const response = await VLogUtils.fetchWithTimeout('/api/auth/csrf-token', {
                            credentials: 'same-origin'
                        });
                        if (response.ok) {
                            const data = await response.json();
                            this.csrfToken = data.csrf_token || '';
                        }
                    } catch (e) {
                        console.error('Failed to fetch CSRF token:', e);
                    }
                },

                // Helper function to make authenticated API requests
                // Note: Authentication is now via HTTP-only cookies (set by /api/auth/login)
                // Cookies are sent automatically with same-origin requests
                // CSRF token is included for state-changing requests (POST, PUT, DELETE, PATCH)
                // If CSRF validation fails, automatically refreshes token and retries once
                async apiFetch(url, options = {}, timeoutMs = 30000, _isRetry = false) {
                    // Clone options to avoid mutating the original
                    const fetchOptions = { ...options, headers: { ...options.headers } };

                    // Add CSRF token header for state-changing requests
                    const method = (fetchOptions.method || 'GET').toUpperCase();
                    const csrfMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];
                    if (csrfMethods.includes(method) && this.csrfToken) {
                        fetchOptions.headers['X-CSRF-Token'] = this.csrfToken;
                    }

                    const response = await VLogUtils.fetchWithTimeout(url, {
                        ...fetchOptions,
                        credentials: 'same-origin',  // Ensure cookies are sent
                    }, timeoutMs);

                    // Handle auth errors
                    if (response.status === 401) {
                        this.authRequired = true;
                        this.isAuthenticated = false;
                        this.showAuthModal = true;
                        throw new Error('Authentication required');
                    }

                    // Handle CSRF errors specifically
                    if (response.status === 403) {
                        const data = await response.clone().json().catch(() => ({}));
                        if (data.detail && data.detail.includes('CSRF')) {
                            // CSRF token might be stale - refresh and retry once
                            if (!_isRetry) {
                                await this.fetchCsrfToken();
                                return this.apiFetch(url, options, timeoutMs, true);
                            }
                            // Already retried, give up
                            throw new Error('CSRF validation failed');
                        }
                        this.authRequired = true;
                        this.isAuthenticated = false;
                        this.showAuthModal = true;
                        throw new Error('Authentication required');
                    }

                    return response;
                },

                // Submit authentication via server-side session
                async submitAuth() {
                    this.authError = '';
                    this.authLoading = true;

                    try {
                        // Authenticate via the login endpoint
                        // Server will set an HTTP-only cookie on success
                        const response = await VLogUtils.fetchWithTimeout('/api/auth/login', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'same-origin',
                            body: JSON.stringify({ secret: this.authSecretInput })
                        });

                        if (response.status === 403) {
                            this.authError = 'Invalid admin secret';
                            return;
                        }

                        if (!response.ok) {
                            const data = await response.json().catch(() => ({}));
                            this.authError = data.detail || `Server error: ${response.status}`;
                            return;
                        }

                        // Success - server has set the session cookie
                        this.isAuthenticated = true;
                        this.showAuthModal = false;
                        this.authSecretInput = '';

                        // Fetch CSRF token for state-changing requests
                        await this.fetchCsrfToken();

                        // Reload data now that we're authenticated
                        await Promise.all([
                            this.loadVideos(),
                            this.loadCategories()
                        ]);
                    } catch (e) {
                        this.authError = 'Failed to authenticate: ' + e.message;
                    } finally {
                        this.authLoading = false;
                    }
                },

                // Log out and clear session
                async logout() {
                    try {
                        await VLogUtils.fetchWithTimeout('/api/auth/logout', {
                            method: 'POST',
                            credentials: 'same-origin'
                        });
                    } catch (e) {
                        console.error('Logout failed:', e);
                    }
                    this.isAuthenticated = false;
                    this.authRequired = true;
                    this.showAuthModal = true;
                    this.csrfToken = '';  // Clear CSRF token on logout
                },

                // Check if authentication is required
                async checkAuth() {
                    try {
                        const response = await VLogUtils.fetchWithTimeout('/api/auth/check', {
                            credentials: 'same-origin'
                        });

                        if (!response.ok) {
                            console.error('Auth check failed with status:', response.status);
                            return false;
                        }

                        const data = await response.json();
                        this.authRequired = data.auth_required;
                        this.isAuthenticated = data.authenticated;

                        if (!data.authenticated && data.auth_required) {
                            this.showAuthModal = true;
                            return false;
                        }

                        return true;
                    } catch (e) {
                        console.error('Auth check failed:', e);
                        return true; // Allow to continue on network errors
                    }
                },

                async init() {
                    // Check authentication first
                    const authOk = await this.checkAuth();
                    if (!authOk) {
                        // Focus the auth input after modal is shown
                        this.$nextTick(() => {
                            if (this.$refs.authInput) {
                                this.$refs.authInput.focus();
                            }
                        });
                        return;
                    }

                    // Fetch CSRF token for state-changing requests
                    await this.fetchCsrfToken();

                    await Promise.all([
                        this.loadVideos(),
                        this.loadCategories()
                    ]);

                    // Try to connect to SSE for real-time updates (falls back to polling)
                    this.connectProgressSSE();

                    // Auto-refresh videos every 30 seconds (longer interval since SSE handles progress)
                    setInterval(() => this.loadVideos(), 30000);

                    // Fallback polling for progress if SSE not connected
                    setInterval(() => {
                        if (!this.progressSSE || this.progressSSE.readyState !== EventSource.OPEN) {
                            this.loadProgressForActiveVideos();
                        }
                    }, 5000);

                    // Auto-refresh workers every 10 seconds when workers tab is active (SSE handles real-time)
                    setInterval(() => {
                        if (this.tab === 'workers' && (!this.workersSSE || this.workersSSE.readyState !== EventSource.OPEN)) {
                            this.loadWorkers();
                        }
                    }, 10000);

                    // Connect workers SSE when switching to workers tab
                    this.$watch('tab', (newTab) => {
                        if (newTab === 'workers') {
                            this.connectWorkersSSE();
                        }
                    });

                    // Cleanup SSE connections on page unload
                    window.addEventListener('beforeunload', () => {
                        if (this.progressSSE) {
                            this.progressSSE.close();
                        }
                        if (this.workersSSE) {
                            this.workersSSE.close();
                        }
                    });
                },

                async loadVideos() {
                    try {
                        const res = await this.apiFetch('/api/videos');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        this.videos = await res.json();
                        // Load progress for active videos after loading video list
                        await this.loadProgressForActiveVideos();
                    } catch (e) {
                        console.error('Failed to load videos:', e);
                        this.videos = [];
                    }
                },

                async loadProgressForActiveVideos() {
                    // Get videos that are processing or failed
                    const activeVideos = this.videos.filter(v =>
                        v.status === 'processing' || v.status === 'pending' || v.status === 'failed'
                    );

                    // Fetch progress for each
                    await Promise.all(activeVideos.map(async (video) => {
                        try {
                            const res = await this.apiFetch(`/api/videos/${video.id}/progress`);
                            if (res.ok) {
                                const data = await res.json();
                                this.progressData[video.id] = data;
                            }
                        } catch (e) {
                            console.error(`Failed to load progress for video ${video.id}:`, e);
                        }
                    }));
                },

                connectProgressSSE() {
                    // Close existing connection if any
                    if (this.progressSSE) {
                        this.progressSSE.close();
                    }

                    // Get video IDs that need progress tracking
                    const activeIds = this.videos
                        .filter(v => v.status === 'processing' || v.status === 'pending')
                        .map(v => v.id)
                        .join(',');

                    const url = activeIds
                        ? `/api/events/progress?video_ids=${activeIds}`
                        : '/api/events/progress';

                    try {
                        this.progressSSE = new EventSource(url);

                        this.progressSSE.addEventListener('progress', (e) => {
                            const data = JSON.parse(e.data);
                            this.progressData[data.video_id] = {
                                progress_percent: data.progress_percent,
                                current_step: data.current_step,
                                qualities: data.qualities,
                                last_error: data.last_error,
                                status: data.status
                            };
                        });

                        this.progressSSE.addEventListener('job_completed', (e) => {
                            const data = JSON.parse(e.data);
                            const video = this.videos.find(v => v.id === data.video_id);
                            if (video) {
                                video.status = 'ready';
                            }
                            delete this.progressData[data.video_id];
                            // Refresh video list to get updated qualities
                            this.loadVideos();
                        });

                        this.progressSSE.addEventListener('job_failed', (e) => {
                            const data = JSON.parse(e.data);
                            const video = this.videos.find(v => v.id === data.video_id);
                            if (video && !data.will_retry) {
                                video.status = 'failed';
                            }
                            if (this.progressData[data.video_id]) {
                                this.progressData[data.video_id].last_error = data.error;
                            }
                        });

                        this.progressSSE.addEventListener('initial', (e) => {
                            // Initial state from SSE connection
                            const data = JSON.parse(e.data);
                            if (data.progress) {
                                for (const [videoId, progress] of Object.entries(data.progress)) {
                                    this.progressData[parseInt(videoId)] = progress;
                                }
                            }
                        });

                        this.progressSSE.onopen = () => {
                            console.log('Progress SSE connected');
                            this.sseReconnectAttempts = 0;
                        };

                        this.progressSSE.onerror = (e) => {
                            console.warn('Progress SSE error, will reconnect:', e);
                            this.scheduleSSEReconnect('progress');
                        };
                    } catch (e) {
                        console.warn('Failed to create progress SSE:', e);
                    }
                },

                connectWorkersSSE() {
                    // Close existing connection if any
                    if (this.workersSSE) {
                        this.workersSSE.close();
                    }

                    try {
                        this.workersSSE = new EventSource('/api/events/workers');

                        this.workersSSE.addEventListener('initial', (e) => {
                            const data = JSON.parse(e.data);
                            if (data.workers) {
                                this.workersList = data.workers;
                                this.workerStats = {
                                    total_count: data.total_count,
                                    active_count: data.active_count,
                                    idle_count: data.idle_count,
                                    offline_count: data.offline_count,
                                    disabled_count: data.disabled_count
                                };
                            }
                            if (data.active_jobs) {
                                this.activeJobs = data.active_jobs;
                            }
                        });

                        this.workersSSE.addEventListener('worker_status', (e) => {
                            const data = JSON.parse(e.data);
                            // Update worker in list
                            const worker = this.workersList.find(w => w.worker_id === data.worker_id);
                            if (worker) {
                                worker.status = data.status;
                                worker.current_video_title = data.current_video_slug;
                                worker.current_step = data.current_step;
                                worker.current_progress = data.progress_percent;
                            }
                        });

                        this.workersSSE.addEventListener('job_completed', (e) => {
                            // Refresh active jobs on completion
                            this.loadActiveJobs();
                        });

                        this.workersSSE.addEventListener('job_failed', (e) => {
                            // Refresh active jobs on failure
                            this.loadActiveJobs();
                        });

                        this.workersSSE.addEventListener('progress', (e) => {
                            const data = JSON.parse(e.data);
                            // Update active job progress
                            if (this.activeJobs && this.activeJobs.jobs) {
                                const job = this.activeJobs.jobs.find(j => j.job_id === data.job_id);
                                if (job) {
                                    job.progress_percent = data.progress_percent;
                                    job.current_step = data.current_step;
                                    job.qualities = data.qualities;
                                }
                            }
                        });

                        this.workersSSE.onopen = () => {
                            console.log('Workers SSE connected');
                        };

                        this.workersSSE.onerror = (e) => {
                            console.warn('Workers SSE error, will reconnect:', e);
                            this.scheduleSSEReconnect('workers');
                        };
                    } catch (e) {
                        console.warn('Failed to create workers SSE:', e);
                    }
                },

                async loadActiveJobs() {
                    try {
                        const res = await this.apiFetch('/api/workers/active-jobs');
                        if (res.ok) {
                            this.activeJobs = await res.json();
                        }
                    } catch (e) {
                        console.error('Failed to load active jobs:', e);
                    }
                },

                scheduleSSEReconnect(type) {
                    this.sseReconnectAttempts++;
                    // Exponential backoff: 1s, 2s, 4s, 8s, ... up to max
                    const delay = Math.min(1000 * Math.pow(2, this.sseReconnectAttempts - 1), this.maxSseReconnectDelay);

                    setTimeout(() => {
                        if (type === 'progress') {
                            this.connectProgressSSE();
                        } else if (type === 'workers' && this.tab === 'workers') {
                            this.connectWorkersSSE();
                        }
                    }, delay);
                },

                async loadCategories() {
                    try {
                        const res = await this.apiFetch('/api/categories');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        this.categories = await res.json();
                    } catch (e) {
                        console.error('Failed to load categories:', e);
                        this.categories = [];
                    }
                },

                async uploadVideo() {
                    if (!this.uploadFile || !this.uploadTitle) return;

                    this.uploading = true;
                    this.uploadProgress = 0;
                    this.uploadMessage = '';
                    this.uploadError = false;

                    const formData = new FormData();
                    formData.append('file', this.uploadFile);
                    formData.append('title', this.uploadTitle);
                    formData.append('description', this.uploadDescription);
                    if (this.uploadCategory) {
                        formData.append('category_id', this.uploadCategory);
                    }

                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', '/api/videos', true);
                        xhr.withCredentials = true;  // Send cookies for authentication
                        if (this.csrfToken) {
                            xhr.setRequestHeader('X-CSRF-Token', this.csrfToken);
                        }

                        xhr.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                this.uploadProgress = Math.round((e.loaded / e.total) * 100);
                            }
                        };

                        xhr.onload = () => {
                            if (xhr.status === 200) {
                                this.uploadMessage = 'Video uploaded successfully! Processing will begin shortly.';
                                this.uploadError = false;
                                this.uploadFile = null;
                                this.uploadTitle = '';
                                this.uploadDescription = '';
                                this.uploadCategory = '';
                                this.loadVideos();
                            } else if (xhr.status === 401 || xhr.status === 403) {
                                this.authRequired = true;
                                this.isAuthenticated = false;
                                this.showAuthModal = true;
                                this.uploadMessage = 'Authentication required';
                                this.uploadError = true;
                            } else {
                                this.uploadMessage = 'Upload failed: ' + xhr.responseText;
                                this.uploadError = true;
                            }
                            this.uploading = false;
                            this.uploadProgress = -1;
                        };

                        xhr.onerror = () => {
                            this.uploadMessage = 'Upload failed. Please try again.';
                            this.uploadError = true;
                            this.uploading = false;
                            this.uploadProgress = -1;
                        };

                        xhr.send(formData);
                    } catch (e) {
                        this.uploadMessage = 'Upload failed: ' + e.message;
                        this.uploadError = true;
                        this.uploading = false;
                        this.uploadProgress = -1;
                    }
                },

                async createCategory() {
                    if (!this.newCategoryName) return;

                    try {
                        const res = await this.apiFetch('/api/categories', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: this.newCategoryName,
                                description: this.newCategoryDesc
                            })
                        });

                        if (res.ok) {
                            this.newCategoryName = '';
                            this.newCategoryDesc = '';
                            await this.loadCategories();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to create category');
                        }
                    } catch (e) {
                        alert('Failed to create category: ' + e.message);
                    }
                },

                async deleteCategory(id) {
                    if (!confirm('Delete this category? Videos in it will become uncategorized.')) return;

                    try {
                        await this.apiFetch(`/api/categories/${id}`, { method: 'DELETE' });
                        await this.loadCategories();
                        await this.loadVideos();
                    } catch (e) {
                        alert('Failed to delete category: ' + e.message);
                    }
                },

                async deleteVideo(id) {
                    if (!confirm('Delete this video? This cannot be undone.')) return;

                    try {
                        await this.apiFetch(`/api/videos/${id}`, { method: 'DELETE' });
                        await this.loadVideos();
                    } catch (e) {
                        alert('Failed to delete video: ' + e.message);
                    }
                },

                async retryVideo(id) {
                    try {
                        await this.apiFetch(`/api/videos/${id}/retry`, { method: 'POST' });
                        await this.loadVideos();
                    } catch (e) {
                        alert('Failed to retry: ' + e.message);
                    }
                },

                async togglePublish(video) {
                    const action = video.published_at ? 'unpublish' : 'publish';
                    try {
                        await this.apiFetch(`/api/videos/${video.id}/${action}`, { method: 'POST' });
                        // Update the video in-place for instant feedback
                        video.published_at = action === 'publish' ? new Date().toISOString() : null;
                    } catch (e) {
                        alert(`Failed to ${action}: ` + e.message);
                    }
                },

                openReuploadModal(video) {
                    this.reuploadVideoId = video.id;
                    this.reuploadTitle = video.title;
                    this.reuploadFile = null;
                    this.reuploading = false;
                    this.reuploadProgress = -1;
                    this.reuploadMessage = '';
                    this.reuploadError = false;
                    this.reuploadModal = true;
                },

                async reuploadVideo() {
                    if (!this.reuploadFile) return;

                    this.reuploading = true;
                    this.reuploadProgress = 0;
                    this.reuploadMessage = '';
                    this.reuploadError = false;

                    const formData = new FormData();
                    formData.append('file', this.reuploadFile);

                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', `/api/videos/${this.reuploadVideoId}/re-upload`, true);
                        xhr.withCredentials = true;  // Send cookies for authentication
                        if (this.csrfToken) {
                            xhr.setRequestHeader('X-CSRF-Token', this.csrfToken);
                        }

                        xhr.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                this.reuploadProgress = Math.round((e.loaded / e.total) * 100);
                            }
                        };

                        xhr.onload = () => {
                            if (xhr.status === 200) {
                                this.reuploadMessage = 'Video uploaded successfully! Processing will begin shortly.';
                                this.reuploadError = false;
                                this.reuploadFile = null;
                                this.loadVideos();
                                // Close modal after a short delay so user sees success message
                                setTimeout(() => {
                                    this.reuploadModal = false;
                                }, 1500);
                            } else if (xhr.status === 401 || xhr.status === 403) {
                                this.authRequired = true;
                                this.isAuthenticated = false;
                                this.showAuthModal = true;
                                this.reuploadMessage = 'Authentication required';
                                this.reuploadError = true;
                            } else {
                                let errorMsg = 'Re-upload failed';
                                try {
                                    const data = JSON.parse(xhr.responseText);
                                    errorMsg = data.detail || errorMsg;
                                } catch (e) {
                                    errorMsg = xhr.responseText || errorMsg;
                                }
                                this.reuploadMessage = errorMsg;
                                this.reuploadError = true;
                            }
                            this.reuploading = false;
                            this.reuploadProgress = -1;
                        };

                        xhr.onerror = () => {
                            this.reuploadMessage = 'Re-upload failed. Please try again.';
                            this.reuploadError = true;
                            this.reuploading = false;
                            this.reuploadProgress = -1;
                        };

                        xhr.send(formData);
                    } catch (e) {
                        this.reuploadMessage = 'Re-upload failed: ' + e.message;
                        this.reuploadError = true;
                        this.reuploading = false;
                        this.reuploadProgress = -1;
                    }
                },

                async openRetranscodeModal(video) {
                    this.retranscodeVideoId = video.id;
                    this.retranscodeTitle = video.title;
                    this.retranscodeSelected = [];
                    this.retranscoding = false;
                    this.retranscodeMessage = '';
                    this.retranscodeError = false;

                    // Fetch available qualities
                    try {
                        const res = await this.apiFetch(`/api/videos/${video.id}/qualities`);
                        if (res.ok) {
                            const data = await res.json();
                            this.retranscodeAvailable = data.available_qualities || [];
                            this.retranscodeExisting = data.existing_qualities || [];
                        } else {
                            this.retranscodeAvailable = [];
                            this.retranscodeExisting = [];
                        }
                    } catch (e) {
                        console.error('Failed to load qualities:', e);
                        this.retranscodeAvailable = [];
                        this.retranscodeExisting = [];
                    }

                    this.retranscodeModal = true;
                },

                async retranscodeAll(video) {
                    if (!confirm(`Re-transcode all qualities for "${video.title}"? This will delete all existing transcoded files and re-process the video.`)) return;

                    try {
                        const res = await this.apiFetch(`/api/videos/${video.id}/retranscode`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ qualities: ['all'] })
                        });

                        if (res.ok) {
                            await this.loadVideos();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Re-transcode failed');
                        }
                    } catch (e) {
                        alert('Re-transcode failed: ' + e.message);
                    }
                },

                async submitRetranscode() {
                    if (this.retranscodeSelected.length === 0) {
                        this.retranscodeMessage = 'Please select at least one quality';
                        this.retranscodeError = true;
                        return;
                    }

                    this.retranscoding = true;
                    this.retranscodeMessage = '';
                    this.retranscodeError = false;

                    try {
                        const res = await this.apiFetch(`/api/videos/${this.retranscodeVideoId}/retranscode`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ qualities: this.retranscodeSelected })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            this.retranscodeMessage = `Queued for re-transcoding: ${data.qualities_queued.join(', ')}`;
                            this.retranscodeError = false;
                            await this.loadVideos();
                            setTimeout(() => {
                                this.retranscodeModal = false;
                            }, 1500);
                        } else {
                            const data = await res.json();
                            this.retranscodeMessage = data.detail || 'Re-transcode failed';
                            this.retranscodeError = true;
                        }
                    } catch (e) {
                        this.retranscodeMessage = 'Re-transcode failed: ' + e.message;
                        this.retranscodeError = true;
                    }

                    this.retranscoding = false;
                },

                toggleRetranscodeQuality(quality) {
                    const idx = this.retranscodeSelected.indexOf(quality);
                    if (idx === -1) {
                        this.retranscodeSelected.push(quality);
                    } else {
                        this.retranscodeSelected.splice(idx, 1);
                    }
                },

                selectAllQualities() {
                    this.retranscodeSelected = [...this.retranscodeAvailable];
                },

                deselectAllQualities() {
                    this.retranscodeSelected = [];
                },

                getQualityStatus(quality) {
                    const existing = this.retranscodeExisting.find(q => q.name === quality);
                    return existing ? existing.status : 'not transcoded';
                },

                // Thumbnail selection methods
                openThumbnailModal(video) {
                    this.thumbnailVideoId = video.id;
                    this.thumbnailVideoSlug = video.slug;
                    this.thumbnailVideoTitle = video.title;
                    this.thumbnailDuration = video.duration;
                    this.thumbnailSource = video.thumbnail_source || 'auto';
                    this.thumbnailFrames = [];
                    this.thumbnailLoading = false;
                    this.thumbnailUploading = false;
                    this.thumbnailUploadFile = null;
                    this.thumbnailCacheBust = Date.now();
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;
                    this.thumbnailModal = true;
                },

                async generateThumbnailFrames() {
                    this.thumbnailLoading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/frames`, {
                            method: 'POST'
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to generate frames');
                        }

                        const data = await res.json();
                        this.thumbnailFrames = data.frames;
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailLoading = false;
                    }
                },

                async selectThumbnailFrame(timestamp) {
                    this.thumbnailLoading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const formData = new FormData();
                        formData.append('timestamp', timestamp);

                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/select`, {
                            method: 'POST',
                            body: formData
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to select frame');
                        }

                        this.thumbnailSource = 'selected';
                        this.thumbnailCacheBust = Date.now();
                        this.thumbnailMessage = 'Thumbnail updated successfully';
                        this.thumbnailError = false;
                        await this.loadVideos();
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailLoading = false;
                    }
                },

                async uploadCustomThumbnail() {
                    if (!this.thumbnailUploadFile) return;

                    this.thumbnailUploading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const formData = new FormData();
                        formData.append('file', this.thumbnailUploadFile);

                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/upload`, {
                            method: 'POST',
                            body: formData
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to upload thumbnail');
                        }

                        this.thumbnailSource = 'custom';
                        this.thumbnailCacheBust = Date.now();
                        this.thumbnailMessage = 'Thumbnail uploaded successfully';
                        this.thumbnailError = false;
                        this.thumbnailUploadFile = null;
                        await this.loadVideos();
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailUploading = false;
                    }
                },

                async revertThumbnail() {
                    this.thumbnailLoading = true;
                    this.thumbnailMessage = '';
                    this.thumbnailError = false;

                    try {
                        const res = await this.apiFetch(`/api/videos/${this.thumbnailVideoId}/thumbnail/revert`, {
                            method: 'POST'
                        });

                        if (!res.ok) {
                            const data = await res.json();
                            throw new Error(data.detail || 'Failed to revert thumbnail');
                        }

                        this.thumbnailSource = 'auto';
                        this.thumbnailCacheBust = Date.now();
                        this.thumbnailMessage = 'Thumbnail reverted to auto-generated';
                        this.thumbnailError = false;
                        await this.loadVideos();
                    } catch (e) {
                        this.thumbnailError = true;
                        this.thumbnailMessage = e.message;
                    } finally {
                        this.thumbnailLoading = false;
                    }
                },

                async openEditModal(video) {
                    this.editVideoId = video.id;
                    this.editTitle = video.title;
                    this.editDescription = video.description || '';
                    this.editCategory = video.category_id || 0;
                    // Convert ISO datetime to datetime-local format (YYYY-MM-DDTHH:MM)
                    if (video.published_at) {
                        this.editPublishedAt = video.published_at.slice(0, 16);
                    } else {
                        this.editPublishedAt = '';
                    }
                    // Load custom fields for this video
                    this.editCustomFieldValues = {};
                    await this.loadVideoCustomFields(video.id);
                    this.editModal = true;
                },

                async saveVideo() {
                    if (!this.editTitle) return;

                    try {
                        const formData = new FormData();
                        formData.append('title', this.editTitle);
                        formData.append('description', this.editDescription);
                        formData.append('category_id', this.editCategory);
                        formData.append('published_at', this.editPublishedAt);

                        const res = await this.apiFetch(`/api/videos/${this.editVideoId}`, {
                            method: 'PUT',
                            body: formData
                        });

                        if (res.ok) {
                            // Save custom fields if any
                            await this.saveVideoCustomFields(this.editVideoId);
                            this.editModal = false;
                            await this.loadVideos();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to update video');
                        }
                    } catch (e) {
                        alert('Failed to update video: ' + e.message);
                    }
                },

                formatDuration(seconds) {
                    if (!seconds) return '-';
                    const h = Math.floor(seconds / 3600);
                    const m = Math.floor((seconds % 3600) / 60);
                    const s = Math.floor(seconds % 60);
                    if (h > 0) {
                        return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                    }
                    return `${m}:${s.toString().padStart(2, '0')}`;
                },

                // Analytics methods
                async loadAnalytics() {
                    await Promise.all([
                        this.loadAnalyticsOverview(),
                        this.loadVideoAnalytics()
                    ]);
                },

                async loadAnalyticsOverview() {
                    try {
                        const res = await this.apiFetch('/api/analytics/overview');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        this.analyticsOverview = await res.json();
                    } catch (e) {
                        console.error('Failed to load analytics overview:', e);
                        this.analyticsOverview = {};
                    }
                },

                async loadVideoAnalytics() {
                    try {
                        const res = await this.apiFetch(`/api/analytics/videos?period=${this.analyticsPeriod}&limit=20&sort_by=views`);
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        const data = await res.json();
                        this.analyticsVideos = data.videos || [];
                    } catch (e) {
                        console.error('Failed to load video analytics:', e);
                        this.analyticsVideos = [];
                    }
                },

                formatHours(hours) {
                    if (!hours) return '0h';
                    if (hours < 1) return Math.round(hours * 60) + 'm';
                    return hours.toFixed(1) + 'h';
                },

                formatPercent(rate) {
                    if (rate === undefined || rate === null) return '0%';
                    return Math.round(rate * 100) + '%';
                },

                formatWatchTime(seconds) {
                    if (!seconds) return '0m';
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    if (hours > 0) return `${hours}h ${minutes}m`;
                    return `${minutes}m`;
                },

                // Worker management methods
                async loadWorkers() {
                    try {
                        const [workersRes, jobsRes] = await Promise.all([
                            this.apiFetch('/api/workers'),
                            this.apiFetch('/api/workers/active-jobs')
                        ]);

                        if (workersRes.ok) {
                            const data = await workersRes.json();
                            this.workersList = data.workers || [];
                            this.workerStats = {
                                total_count: data.total_count,
                                active_count: data.active_count,
                                idle_count: data.idle_count,
                                offline_count: data.offline_count,
                                disabled_count: data.disabled_count
                            };
                        } else {
                            console.error('Failed to load workers:', workersRes.status);
                            this.workersList = [];
                            this.workerStats = {};
                        }

                        if (jobsRes.ok) {
                            this.activeJobs = await jobsRes.json();
                        } else {
                            console.error('Failed to load active jobs:', jobsRes.status);
                            this.activeJobs = { jobs: [], total_count: 0, processing_count: 0, pending_count: 0 };
                        }
                    } catch (e) {
                        console.error('Failed to load workers:', e);
                        this.workersList = [];
                        this.workerStats = {};
                        this.activeJobs = { jobs: [], total_count: 0, processing_count: 0, pending_count: 0 };
                    }
                },

                async disableWorker(workerId) {
                    if (!confirm('Disable this worker? It will not be able to claim new jobs.')) return;

                    try {
                        const res = await this.apiFetch(`/api/workers/${workerId}/disable`, { method: 'PUT' });
                        if (res.ok) {
                            await this.loadWorkers();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to disable worker');
                        }
                    } catch (e) {
                        alert('Failed to disable worker: ' + e.message);
                    }
                },

                async enableWorker(workerId) {
                    try {
                        const res = await this.apiFetch(`/api/workers/${workerId}/enable`, { method: 'PUT' });
                        if (res.ok) {
                            await this.loadWorkers();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to enable worker');
                        }
                    } catch (e) {
                        alert('Failed to enable worker: ' + e.message);
                    }
                },

                async deleteWorker(workerId, workerName) {
                    const name = workerName || workerId.slice(0, 8);
                    if (!confirm(`Delete worker "${name}"? This will revoke its API key and remove it from the system.`)) return;

                    try {
                        const res = await this.apiFetch(`/api/workers/${workerId}`, { method: 'DELETE' });
                        if (res.ok) {
                            await this.loadWorkers();
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to delete worker');
                        }
                    } catch (e) {
                        alert('Failed to delete worker: ' + e.message);
                    }
                },

                // Worker remote control methods (Issue #410)
                workerCommandPending: {},

                async restartWorker(workerId, workerName) {
                    const name = workerName || workerId.slice(0, 8);
                    if (!confirm(`Restart worker "${name}"?\n\nThe worker will finish its current job before restarting.`)) return;

                    this.workerCommandPending[workerId] = true;
                    try {
                        const res = await this.apiFetch(`/api/admin/workers/${workerId}/restart`, { method: 'POST' });
                        if (res.ok) {
                            const data = await res.json();
                            // Show success feedback briefly
                            setTimeout(() => {
                                delete this.workerCommandPending[workerId];
                                this.loadWorkers();
                            }, 3000);
                        } else {
                            const data = await res.json();
                            delete this.workerCommandPending[workerId];
                            alert(data.detail || 'Failed to send restart command');
                        }
                    } catch (e) {
                        delete this.workerCommandPending[workerId];
                        alert('Failed to send restart command: ' + e.message);
                    }
                },

                async updateWorker(workerId, workerName) {
                    const name = workerName || workerId.slice(0, 8);
                    if (!confirm(`Update worker "${name}"?\n\nThe worker will:\n1. Finish its current job\n2. Pull latest code via git\n3. Restart to apply updates`)) return;

                    this.workerCommandPending[workerId] = true;
                    try {
                        const res = await this.apiFetch(`/api/admin/workers/${workerId}/update`, { method: 'POST' });
                        if (res.ok) {
                            const data = await res.json();
                            setTimeout(() => {
                                delete this.workerCommandPending[workerId];
                                this.loadWorkers();
                            }, 3000);
                        } else {
                            const data = await res.json();
                            delete this.workerCommandPending[workerId];
                            alert(data.detail || 'Failed to send update command');
                        }
                    } catch (e) {
                        delete this.workerCommandPending[workerId];
                        alert('Failed to send update command: ' + e.message);
                    }
                },

                async restartAllWorkers() {
                    if (!confirm('Restart ALL workers?\n\nEach worker will finish its current job before restarting.\nThis is useful for deploying updates across all workers.')) return;

                    try {
                        const res = await this.apiFetch('/api/admin/workers/restart-all', { method: 'POST' });
                        if (res.ok) {
                            // Mark all workers as pending
                            this.workersList.forEach(w => {
                                if (w.status !== 'offline' && w.status !== 'disabled') {
                                    this.workerCommandPending[w.worker_id] = true;
                                }
                            });
                            setTimeout(() => {
                                this.workerCommandPending = {};
                                this.loadWorkers();
                            }, 5000);
                        } else {
                            const data = await res.json();
                            alert(data.detail || 'Failed to broadcast restart command');
                        }
                    } catch (e) {
                        alert('Failed to broadcast restart command: ' + e.message);
                    }
                },

                // Worker logs and metrics viewer (Phase 3)
                showLogsModal: false,
                showMetricsModal: false,
                logsWorkerName: '',
                logsContent: '',
                logsLoading: false,
                metricsWorkerName: '',
                metricsData: null,
                metricsLoading: false,

                // Deployment history (Phase 4)
                deploymentEvents: [],
                deploymentEventsLoading: false,

                async loadDeploymentHistory() {
                    this.deploymentEventsLoading = true;
                    try {
                        const res = await this.apiFetch('/api/admin/deployments?limit=50');
                        if (res.ok) {
                            const data = await res.json();
                            this.deploymentEvents = data.events || [];
                        }
                    } catch (e) {
                        console.error('Failed to load deployment history:', e);
                    } finally {
                        this.deploymentEventsLoading = false;
                    }
                },

                formatDeploymentTime(isoStr) {
                    if (!isoStr) return '';
                    const date = new Date(isoStr);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);

                    if (diffMins < 1) return 'just now';
                    if (diffMins < 60) return `${diffMins}m ago`;
                    if (diffHours < 24) return `${diffHours}h ago`;
                    if (diffDays < 7) return `${diffDays}d ago`;
                    return date.toLocaleDateString();
                },

                getEventIcon(eventType) {
                    switch(eventType) {
                        case 'restart': return 'R';
                        case 'stop': return 'S';
                        case 'update': return 'U';
                        case 'version_change': return 'V';
                        default: return eventType[0].toUpperCase();
                    }
                },

                getEventColor(eventType, status) {
                    if (status === 'failed') return 'bg-red-500';
                    if (status === 'in_progress' || status === 'pending') return 'bg-yellow-500';
                    switch(eventType) {
                        case 'restart': return 'bg-blue-500';
                        case 'update': return 'bg-purple-500';
                        case 'stop': return 'bg-red-500';
                        case 'version_change': return 'bg-green-500';
                        default: return 'bg-dark-500';
                    }
                },

                async viewWorkerLogs(workerId, workerName) {
                    this.logsWorkerName = workerName || workerId.slice(0, 8);
                    this.logsContent = '';
                    this.logsLoading = true;
                    this.showLogsModal = true;

                    try {
                        const res = await this.apiFetch(`/api/admin/workers/${workerId}/logs?lines=200`);
                        if (res.ok) {
                            const data = await res.json();
                            this.logsContent = data.logs || 'No logs available';
                        } else {
                            const data = await res.json();
                            this.logsContent = `Error: ${data.detail || 'Failed to fetch logs'}`;
                        }
                    } catch (e) {
                        this.logsContent = `Error: ${e.message}`;
                    } finally {
                        this.logsLoading = false;
                    }
                },

                async viewWorkerMetrics(workerId, workerName) {
                    this.metricsWorkerName = workerName || workerId.slice(0, 8);
                    this.metricsData = null;
                    this.metricsLoading = true;
                    this.showMetricsModal = true;

                    try {
                        const res = await this.apiFetch(`/api/admin/workers/${workerId}/metrics`);
                        if (res.ok) {
                            const data = await res.json();
                            this.metricsData = data.metrics;
                        } else {
                            const data = await res.json();
                            this.metricsData = { error: data.detail || 'Failed to fetch metrics' };
                        }
                    } catch (e) {
                        this.metricsData = { error: e.message };
                    } finally {
                        this.metricsLoading = false;
                    }
                },

                formatBytes(gb) {
                    if (gb >= 1) return gb.toFixed(1) + ' GB';
                    return (gb * 1024).toFixed(0) + ' MB';
                },

                formatTimeSince(seconds) {
                    if (seconds === null || seconds === undefined) return '';
                    if (seconds < 60) return seconds + 's ago';
                    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
                    if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
                    return Math.floor(seconds / 86400) + 'd ago';
                },

                isVersionOutdated(version) {
                    // Compare against the most common version among online workers
                    if (!version || !this.workersList || this.workersList.length === 0) return false;

                    // Get versions from online workers only
                    const onlineWorkers = this.workersList.filter(w =>
                        w.status !== 'offline' && w.status !== 'disabled' && w.code_version
                    );
                    if (onlineWorkers.length === 0) return false;

                    // Find the most common version (likely the "current" version)
                    const versionCounts = {};
                    onlineWorkers.forEach(w => {
                        versionCounts[w.code_version] = (versionCounts[w.code_version] || 0) + 1;
                    });

                    const latestVersion = Object.entries(versionCounts)
                        .sort((a, b) => b[1] - a[1])[0][0];

                    return version !== latestVersion;
                },

                formatDate(dateStr) {
                    if (!dateStr) return 'N/A';
                    const date = new Date(dateStr);
                    return date.toLocaleString();
                },

                // Bulk operation methods
                toggleSelectAll() {
                    if (this.selectedVideos.length === this.videos.length) {
                        this.selectedVideos = [];
                    } else {
                        this.selectedVideos = this.videos.map(v => v.id);
                    }
                },

                toggleVideoSelection(videoId) {
                    const idx = this.selectedVideos.indexOf(videoId);
                    if (idx === -1) {
                        this.selectedVideos.push(videoId);
                    } else {
                        this.selectedVideos.splice(idx, 1);
                    }
                },

                clearSelection() {
                    this.selectedVideos = [];
                },

                openBulkDeleteModal() {
                    this.bulkDeletePermanent = false;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;
                    this.bulkDeleteModal = true;
                },

                openBulkUpdateModal() {
                    this.bulkUpdateCategory = '';
                    this.bulkUpdatePublishedAt = '';
                    this.bulkUpdateUnpublish = false;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;
                    this.bulkUpdateModal = true;
                },

                openBulkRetranscodeModal() {
                    this.bulkRetranscodeQuality = 'all';
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;
                    this.bulkRetranscodeModal = true;
                },

                openBulkCustomFieldsModal() {
                    this.bulkCustomFieldValues = {};
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;
                    this.bulkCustomFieldsModal = true;
                },

                toggleBulkMultiSelectOption(fieldId, option) {
                    let current = this.bulkCustomFieldValues[fieldId] || [];
                    if (!Array.isArray(current)) current = [];

                    const idx = current.indexOf(option);
                    if (idx >= 0) {
                        current.splice(idx, 1);
                    } else {
                        current.push(option);
                    }
                    this.bulkCustomFieldValues[fieldId] = [...current];
                },

                async executeBulkCustomFields() {
                    // Filter out empty values
                    const values = {};
                    for (const [fieldId, value] of Object.entries(this.bulkCustomFieldValues)) {
                        if (value !== '' && value !== null && value !== undefined) {
                            if (Array.isArray(value) && value.length === 0) continue;
                            values[fieldId] = value;
                        }
                    }

                    if (Object.keys(values).length === 0) {
                        this.bulkOpMessage = 'No field values specified';
                        this.bulkOpError = true;
                        return;
                    }

                    this.bulkOpLoading = true;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/custom-fields', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                video_ids: this.selectedVideos,
                                values: values
                            })
                        });

                        const data = await res.json();
                        if (res.ok) {
                            this.bulkOpMessage = `Updated ${data.updated} video(s)` + (data.failed > 0 ? `, ${data.failed} failed` : '');
                            this.bulkOpError = data.failed > 0;
                            this.selectedVideos = [];
                            setTimeout(() => { this.bulkCustomFieldsModal = false; }, 1500);
                        } else {
                            this.bulkOpMessage = data.detail || 'Update failed';
                            this.bulkOpError = true;
                        }
                    } catch (e) {
                        this.bulkOpMessage = 'Update failed: ' + e.message;
                        this.bulkOpError = true;
                    }

                    this.bulkOpLoading = false;
                },

                async executeBulkDelete() {
                    this.bulkOpLoading = true;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/delete', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                video_ids: this.selectedVideos,
                                permanent: this.bulkDeletePermanent
                            })
                        });

                        const data = await res.json();
                        if (res.ok) {
                            this.bulkOpMessage = `Deleted ${data.deleted} video(s)` + (data.failed > 0 ? `, ${data.failed} failed` : '');
                            this.bulkOpError = data.failed > 0;
                            await this.loadVideos();
                            this.selectedVideos = [];
                            setTimeout(() => { this.bulkDeleteModal = false; }, 1500);
                        } else {
                            this.bulkOpMessage = data.detail || 'Delete failed';
                            this.bulkOpError = true;
                        }
                    } catch (e) {
                        this.bulkOpMessage = 'Delete failed: ' + e.message;
                        this.bulkOpError = true;
                    }

                    this.bulkOpLoading = false;
                },

                async executeBulkUpdate() {
                    // Build update payload
                    const payload = { video_ids: this.selectedVideos };

                    if (this.bulkUpdateCategory !== '') {
                        payload.category_id = parseInt(this.bulkUpdateCategory);
                    }
                    if (this.bulkUpdateUnpublish) {
                        payload.unpublish = true;
                    } else if (this.bulkUpdatePublishedAt) {
                        payload.published_at = this.bulkUpdatePublishedAt;
                    }

                    const hasUpdates = (payload.category_id !== undefined) || payload.unpublish || payload.published_at;
                    if (!hasUpdates) {
                        this.bulkOpMessage = 'Please select at least one field to update';
                        this.bulkOpError = true;
                        return;
                    }

                    this.bulkOpLoading = true;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/update', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        const data = await res.json();
                        if (res.ok) {
                            this.bulkOpMessage = `Updated ${data.updated} video(s)` + (data.failed > 0 ? `, ${data.failed} failed` : '');
                            this.bulkOpError = data.failed > 0;
                            await this.loadVideos();
                            this.selectedVideos = [];
                            setTimeout(() => { this.bulkUpdateModal = false; }, 1500);
                        } else {
                            this.bulkOpMessage = data.detail || 'Update failed';
                            this.bulkOpError = true;
                        }
                    } catch (e) {
                        this.bulkOpMessage = 'Update failed: ' + e.message;
                        this.bulkOpError = true;
                    }

                    this.bulkOpLoading = false;
                },

                async executeBulkRetranscode() {
                    this.bulkOpLoading = true;
                    this.bulkOpMessage = '';
                    this.bulkOpError = false;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/retranscode', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                video_ids: this.selectedVideos,
                                qualities: [this.bulkRetranscodeQuality]
                            })
                        });

                        const data = await res.json();
                        if (res.ok) {
                            this.bulkOpMessage = `Queued ${data.queued} video(s) for re-transcoding` + (data.failed > 0 ? `, ${data.failed} failed` : '');
                            this.bulkOpError = data.failed > 0;
                            await this.loadVideos();
                            this.selectedVideos = [];
                            setTimeout(() => { this.bulkRetranscodeModal = false; }, 1500);
                        } else {
                            this.bulkOpMessage = data.detail || 'Re-transcode failed';
                            this.bulkOpError = true;
                        }
                    } catch (e) {
                        this.bulkOpMessage = 'Re-transcode failed: ' + e.message;
                        this.bulkOpError = true;
                    }

                    this.bulkOpLoading = false;
                },

                async bulkRestoreVideos() {
                    if (!confirm(`Restore ${this.selectedVideos.length} video(s) from archive?`)) return;

                    try {
                        const res = await this.apiFetch('/api/videos/bulk/restore', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ video_ids: this.selectedVideos })
                        });

                        const data = await res.json();
                        if (res.ok) {
                            alert(`Restored ${data.restored} video(s)` + (data.failed > 0 ? `, ${data.failed} failed` : ''));
                            await this.loadVideos();
                            this.selectedVideos = [];
                        } else {
                            alert(data.detail || 'Restore failed');
                        }
                    } catch (e) {
                        alert('Restore failed: ' + e.message);
                    }
                },

                async exportVideos() {
                    try {
                        const res = await this.apiFetch('/api/videos/export');
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        const data = await res.json();

                        // Create downloadable JSON file
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `vlog-export-${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        alert('Export failed: ' + e.message);
                    }
                },

                // Database-backed settings methods
                async loadSettingsCategories() {
                    this.settingsLoading = true;
                    try {
                        const res = await this.apiFetch('/api/settings/categories');
                        if (res.ok) {
                            this.settingsCategories = await res.json();
                        }
                    } catch (e) {
                        console.error('Failed to load settings categories:', e);
                    } finally {
                        this.settingsLoading = false;
                    }
                },

                async loadSettingsCategory(category) {
                    this.settingsLoadingCategory = category;
                    this.settingsMessage = '';
                    this.settingsError = false;

                    try {
                        const res = await this.apiFetch(`/api/settings/category/${category}`);
                        if (res.ok) {
                            const data = await res.json();
                            this.settingsByCategory[category] = data.settings;
                            // Store original values for reset
                            this.settingsOriginal[category] = JSON.parse(JSON.stringify(data.settings));
                            // Clear modified tracking
                            if (!this.settingsModified[category]) {
                                this.settingsModified[category] = {};
                            }
                        }
                    } catch (e) {
                        console.error(`Failed to load settings for ${category}:`, e);
                    } finally {
                        this.settingsLoadingCategory = null;
                    }
                },

                async loadAllSettings() {
                    this.settingsLoading = true;
                    this.settingsMessage = '';
                    this.settingsError = false;

                    try {
                        const res = await this.apiFetch('/api/settings');
                        if (res.ok) {
                            const data = await res.json();
                            this.settingsByCategory = data.categories || {};
                            this.settingsCategories = Object.keys(this.settingsByCategory);
                            // Store original values for reset
                            this.settingsOriginal = JSON.parse(JSON.stringify(this.settingsByCategory));
                            // Initialize modified tracking
                            this.settingsModified = {};
                            for (const cat of this.settingsCategories) {
                                this.settingsModified[cat] = {};
                            }
                        }
                    } catch (e) {
                        console.error('Failed to load settings:', e);
                    } finally {
                        this.settingsLoading = false;
                    }
                },

                markSettingModified(category, key, value) {
                    if (!this.settingsModified[category]) {
                        this.settingsModified[category] = {};
                    }
                    this.settingsModified[category][key] = value;
                },

                hasModifiedSettings(category) {
                    return this.settingsModified[category] &&
                           Object.keys(this.settingsModified[category]).length > 0;
                },

                async saveSetting(category, key) {
                    this.settingsSaving = true;
                    this.settingsMessage = '';
                    this.settingsError = false;

                    try {
                        const setting = this.settingsByCategory[category]?.find(s => s.key === key);
                        if (!setting) return;

                        const res = await this.apiFetch(`/api/settings/key/${key}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ value: setting.value })
                        });

                        if (res.ok) {
                            this.settingsMessage = `Setting "${key}" saved successfully`;
                            this.settingsError = false;
                            // Remove from modified tracking
                            if (this.settingsModified[category]) {
                                delete this.settingsModified[category][key];
                            }
                            // Update original value
                            const origSetting = this.settingsOriginal[category]?.find(s => s.key === key);
                            if (origSetting) {
                                origSetting.value = setting.value;
                            }
                        } else {
                            const data = await res.json();
                            this.settingsMessage = data.detail || 'Failed to save setting';
                            this.settingsError = true;
                        }
                    } catch (e) {
                        this.settingsMessage = 'Failed to save: ' + e.message;
                        this.settingsError = true;
                    } finally {
                        this.settingsSaving = false;
                    }
                },

                async saveAllCategorySettings(category) {
                    if (!this.hasModifiedSettings(category)) return;

                    this.settingsSaving = true;
                    this.settingsMessage = '';
                    this.settingsError = false;

                    const modifiedKeys = Object.keys(this.settingsModified[category] || {});
                    let savedCount = 0;
                    let errors = [];

                    for (const key of modifiedKeys) {
                        try {
                            const setting = this.settingsByCategory[category]?.find(s => s.key === key);
                            if (!setting) continue;

                            const res = await this.apiFetch(`/api/settings/key/${key}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ value: setting.value })
                            });

                            if (res.ok) {
                                savedCount++;
                                delete this.settingsModified[category][key];
                                // Update original value
                                const origSetting = this.settingsOriginal[category]?.find(s => s.key === key);
                                if (origSetting) {
                                    origSetting.value = setting.value;
                                }
                            } else {
                                const data = await res.json();
                                errors.push(`${key}: ${data.detail || 'Failed'}`);
                            }
                        } catch (e) {
                            errors.push(`${key}: ${e.message}`);
                        }
                    }

                    this.settingsSaving = false;

                    if (errors.length === 0) {
                        this.settingsMessage = `Saved ${savedCount} setting(s) successfully`;
                        this.settingsError = false;
                    } else {
                        this.settingsMessage = `Saved ${savedCount}, failed ${errors.length}: ${errors.join(', ')}`;
                        this.settingsError = true;
                    }
                },

                resetCategorySettings(category) {
                    if (!this.settingsOriginal[category]) return;

                    // Restore original values
                    this.settingsByCategory[category] = JSON.parse(JSON.stringify(this.settingsOriginal[category]));
                    // Clear modified tracking
                    this.settingsModified[category] = {};
                    this.settingsMessage = 'Settings reset to last saved values';
                    this.settingsError = false;
                },

                getSettingInputType(valueType) {
                    switch (valueType) {
                        case 'boolean': return 'checkbox';
                        case 'integer': return 'number';
                        case 'float': return 'number';
                        case 'enum': return 'select';
                        case 'json': return 'textarea';
                        default: return 'text';
                    }
                },

                formatSettingValue(value, valueType) {
                    if (valueType === 'json') {
                        try {
                            return JSON.stringify(value, null, 2);
                        } catch {
                            return String(value);
                        }
                    }
                    return value;
                },

                parseSettingValue(value, valueType) {
                    switch (valueType) {
                        case 'integer':
                            return parseInt(value, 10);
                        case 'float':
                            return parseFloat(value);
                        case 'boolean':
                            return value === true || value === 'true';
                        case 'json':
                            try {
                                return JSON.parse(value);
                            } catch {
                                return value;
                            }
                        default:
                            return value;
                    }
                },

                async exportSettings() {
                    try {
                        const res = await this.apiFetch('/api/settings/export', {
                            method: 'POST'
                        });
                        if (res.ok) {
                            const data = await res.json();
                            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `vlog-settings-${new Date().toISOString().split('T')[0]}.json`;
                            a.click();
                            URL.revokeObjectURL(url);
                            this.settingsMessage = 'Settings exported successfully';
                            this.settingsError = false;
                        }
                    } catch (e) {
                        this.settingsMessage = 'Export failed: ' + e.message;
                        this.settingsError = true;
                    }
                },

                async importSettings(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);

                        const res = await this.apiFetch('/api/settings/import', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ settings: data.settings, overwrite: true })
                        });

                        if (res.ok) {
                            const result = await res.json();
                            this.settingsMessage = `Import complete: ${result.created} created, ${result.updated} updated, ${result.skipped} skipped`;
                            this.settingsError = result.errors?.length > 0;
                            // Reload settings
                            await this.loadAllSettings();
                        } else {
                            const err = await res.json();
                            this.settingsMessage = err.detail || 'Import failed';
                            this.settingsError = true;
                        }
                    } catch (e) {
                        this.settingsMessage = 'Import failed: ' + e.message;
                        this.settingsError = true;
                    }

                    // Clear file input
                    event.target.value = '';
                },

                // Custom Fields methods
                async loadCustomFields() {
                    this.customFieldsLoading = true;
                    this.customFieldMessage = '';
                    this.customFieldError = false;

                    try {
                        const res = await this.apiFetch('/api/custom-fields');
                        if (res.ok) {
                            const data = await res.json();
                            this.customFields = data.fields || [];
                        } else {
                            console.error('Failed to load custom fields:', res.status);
                        }
                    } catch (e) {
                        console.error('Failed to load custom fields:', e);
                    } finally {
                        this.customFieldsLoading = false;
                    }
                },

                openCreateFieldModal() {
                    this.customFieldEditing = null;
                    this.customFieldForm = {
                        name: '',
                        field_type: 'text',
                        options: [],
                        required: false,
                        category_id: null,
                        position: 0,
                        description: '',
                    };
                    this.customFieldModal = true;
                },

                openEditFieldModal(field) {
                    this.customFieldEditing = field;
                    this.customFieldForm = {
                        name: field.name,
                        field_type: field.field_type,
                        options: field.options ? [...field.options] : [],
                        required: field.required,
                        category_id: field.category_id,
                        position: field.position,
                        description: field.description || '',
                    };
                    this.customFieldModal = true;
                },

                async saveCustomField() {
                    this.customFieldSaving = true;

                    try {
                        // Filter out empty options
                        const options = this.customFieldForm.options.filter(o => o && o.trim());
                        const payload = {
                            name: this.customFieldForm.name,
                            field_type: this.customFieldForm.field_type,
                            options: options.length > 0 ? options : null,
                            required: this.customFieldForm.required,
                            category_id: this.customFieldForm.category_id,
                            position: this.customFieldForm.position,
                            description: this.customFieldForm.description || null,
                        };

                        let res;
                        if (this.customFieldEditing) {
                            // Update - only send editable fields
                            res = await this.apiFetch(`/api/custom-fields/${this.customFieldEditing.id}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    name: payload.name,
                                    options: payload.options,
                                    required: payload.required,
                                    position: payload.position,
                                    description: payload.description,
                                }),
                            });
                        } else {
                            // Create
                            res = await this.apiFetch('/api/custom-fields', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload),
                            });
                        }

                        if (res.ok) {
                            this.customFieldModal = false;
                            this.customFieldMessage = this.customFieldEditing ? 'Field updated successfully' : 'Field created successfully';
                            this.customFieldError = false;
                            await this.loadCustomFields();
                        } else {
                            const err = await res.json();
                            this.customFieldMessage = err.detail || 'Operation failed';
                            this.customFieldError = true;
                        }
                    } catch (e) {
                        this.customFieldMessage = 'Operation failed: ' + e.message;
                        this.customFieldError = true;
                    } finally {
                        this.customFieldSaving = false;
                    }
                },

                async deleteCustomField(field) {
                    if (!confirm(`Delete field "${field.name}"? This will remove all values from videos.`)) {
                        return;
                    }

                    try {
                        const res = await this.apiFetch(`/api/custom-fields/${field.id}`, {
                            method: 'DELETE',
                        });

                        if (res.ok) {
                            const data = await res.json();
                            this.customFieldMessage = `Field deleted. ${data.affected_videos} video(s) affected.`;
                            this.customFieldError = false;
                            await this.loadCustomFields();
                        } else {
                            const err = await res.json();
                            this.customFieldMessage = err.detail || 'Delete failed';
                            this.customFieldError = true;
                        }
                    } catch (e) {
                        this.customFieldMessage = 'Delete failed: ' + e.message;
                        this.customFieldError = true;
                    }
                },

                // Load custom fields for a video (when editing)
                async loadVideoCustomFields(videoId) {
                    try {
                        const res = await this.apiFetch(`/api/videos/${videoId}/custom-fields`);
                        if (res.ok) {
                            const data = await res.json();
                            this.editCustomFields = data.fields || [];
                            this.editCustomFieldValues = {};
                            for (const field of data.fields) {
                                this.editCustomFieldValues[field.field_id] = field.value;
                            }
                        }
                    } catch (e) {
                        console.error('Failed to load video custom fields:', e);
                    }
                },

                // Save custom fields for a video
                async saveVideoCustomFields(videoId) {
                    if (Object.keys(this.editCustomFieldValues).length === 0) return true;

                    try {
                        const res = await this.apiFetch(`/api/videos/${videoId}/custom-fields`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ values: this.editCustomFieldValues }),
                        });
                        return res.ok;
                    } catch (e) {
                        console.error('Failed to save video custom fields:', e);
                        return false;
                    }
                },

                // Toggle multi-select option
                toggleMultiSelectOption(fieldId, option) {
                    let current = this.editCustomFieldValues[fieldId] || [];
                    if (!Array.isArray(current)) current = [];

                    const idx = current.indexOf(option);
                    if (idx >= 0) {
                        current.splice(idx, 1);
                    } else {
                        current.push(option);
                    }
                    this.editCustomFieldValues[fieldId] = [...current];
                },

                // Get applicable custom fields for current video (global + category-specific)
                getApplicableCustomFields() {
                    const categoryId = parseInt(this.editCategory) || 0;
                    return this.customFields.filter(f =>
                        f.category_id === null || f.category_id === categoryId
                    ).sort((a, b) => a.position - b.position);
                },

                // Watermark settings methods
                async loadWatermarkSettings() {
                    this.watermarkLoading = true;
                    this.watermarkMessage = '';
                    this.watermarkError = false;

                    try {
                        const res = await this.apiFetch('/api/settings/watermark');
                        if (res.ok) {
                            this.watermarkSettings = await res.json();
                        } else {
                            console.error('Failed to load watermark settings:', res.status);
                            this.watermarkSettings = null;
                        }
                    } catch (e) {
                        console.error('Failed to load watermark settings:', e);
                        this.watermarkSettings = null;
                    } finally {
                        this.watermarkLoading = false;
                    }
                },

                async uploadWatermarkImage() {
                    if (!this.watermarkImageFile) return;

                    this.watermarkUploading = true;
                    this.watermarkUploadProgress = 0;
                    this.watermarkMessage = '';
                    this.watermarkError = false;

                    const formData = new FormData();
                    formData.append('file', this.watermarkImageFile);

                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', '/api/settings/watermark/upload', true);
                        xhr.withCredentials = true;
                        if (this.csrfToken) {
                            xhr.setRequestHeader('X-CSRF-Token', this.csrfToken);
                        }

                        xhr.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                this.watermarkUploadProgress = Math.round((e.loaded / e.total) * 100);
                            }
                        };

                        xhr.onload = async () => {
                            this.watermarkUploading = false;
                            this.watermarkUploadProgress = 0;

                            if (xhr.status >= 200 && xhr.status < 300) {
                                const data = JSON.parse(xhr.responseText);
                                this.watermarkMessage = data.message || 'Watermark uploaded successfully';
                                this.watermarkError = false;
                                this.watermarkImageFile = null;
                                // Reload settings to show new image
                                await this.loadWatermarkSettings();
                            } else {
                                try {
                                    const data = JSON.parse(xhr.responseText);
                                    this.watermarkMessage = data.detail || 'Upload failed';
                                } catch {
                                    this.watermarkMessage = 'Upload failed: ' + xhr.statusText;
                                }
                                this.watermarkError = true;
                            }
                        };

                        xhr.onerror = () => {
                            this.watermarkUploading = false;
                            this.watermarkUploadProgress = 0;
                            this.watermarkMessage = 'Upload failed: Network error';
                            this.watermarkError = true;
                        };

                        xhr.send(formData);
                    } catch (e) {
                        this.watermarkUploading = false;
                        this.watermarkUploadProgress = 0;
                        this.watermarkMessage = 'Upload failed: ' + e.message;
                        this.watermarkError = true;
                    }
                },

                async deleteWatermarkImage() {
                    if (!confirm('Delete the watermark image?')) return;

                    this.watermarkMessage = '';
                    this.watermarkError = false;

                    try {
                        const res = await this.apiFetch('/api/settings/watermark', {
                            method: 'DELETE'
                        });

                        if (res.ok) {
                            const data = await res.json();
                            this.watermarkMessage = data.message || 'Watermark deleted';
                            this.watermarkError = false;
                            // Reload settings
                            await this.loadWatermarkSettings();
                        } else {
                            const data = await res.json();
                            this.watermarkMessage = data.detail || 'Delete failed';
                            this.watermarkError = true;
                        }
                    } catch (e) {
                        this.watermarkMessage = 'Delete failed: ' + e.message;
                        this.watermarkError = true;
                    }
                }
            };
        }
    </script>

    <!-- Worker Logs Modal -->
    <div x-show="showLogsModal" x-cloak
         class="fixed inset-0 z-50 flex items-center justify-center p-4"
         @keydown.escape.window="showLogsModal = false">
        <!-- Backdrop -->
        <div class="absolute inset-0 bg-black/70" @click="showLogsModal = false"></div>
        <!-- Modal -->
        <div class="relative bg-dark-900 rounded-xl w-full max-w-4xl max-h-[80vh] flex flex-col shadow-2xl border border-dark-700">
            <div class="flex items-center justify-between px-6 py-4 border-b border-dark-700">
                <h3 class="text-lg font-semibold" x-text="'Logs: ' + logsWorkerName"></h3>
                <button @click="showLogsModal = false" class="text-dark-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-auto p-4">
                <template x-if="logsLoading">
                    <div class="flex items-center justify-center py-12">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                        <span class="ml-3 text-dark-400">Fetching logs from worker...</span>
                    </div>
                </template>
                <template x-if="!logsLoading">
                    <pre class="text-sm text-dark-300 font-mono whitespace-pre-wrap bg-dark-950 p-4 rounded-lg overflow-auto max-h-[60vh]"
                         x-text="logsContent || 'No logs available'"></pre>
                </template>
            </div>
        </div>
    </div>

    <!-- Worker Metrics Modal -->
    <div x-show="showMetricsModal" x-cloak
         class="fixed inset-0 z-50 flex items-center justify-center p-4"
         @keydown.escape.window="showMetricsModal = false">
        <!-- Backdrop -->
        <div class="absolute inset-0 bg-black/70" @click="showMetricsModal = false"></div>
        <!-- Modal -->
        <div class="relative bg-dark-900 rounded-xl w-full max-w-2xl shadow-2xl border border-dark-700">
            <div class="flex items-center justify-between px-6 py-4 border-b border-dark-700">
                <h3 class="text-lg font-semibold" x-text="'Metrics: ' + metricsWorkerName"></h3>
                <button @click="showMetricsModal = false" class="text-dark-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="p-6">
                <template x-if="metricsLoading">
                    <div class="flex items-center justify-center py-8">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                        <span class="ml-3 text-dark-400">Fetching metrics from worker...</span>
                    </div>
                </template>
                <template x-if="!metricsLoading && metricsData?.error">
                    <div class="text-red-400 text-center py-4" x-text="metricsData.error"></div>
                </template>
                <template x-if="!metricsLoading && metricsData && !metricsData?.error">
                    <div class="space-y-6">
                        <!-- Process Metrics -->
                        <div>
                            <h4 class="text-sm font-medium text-dark-400 mb-3">Process</h4>
                            <div class="grid grid-cols-3 gap-4">
                                <div class="bg-dark-800 rounded-lg p-3 text-center">
                                    <div class="text-2xl font-bold text-blue-400" x-text="(metricsData?.process?.cpu_percent || 0).toFixed(1) + '%'"></div>
                                    <div class="text-xs text-dark-500">CPU</div>
                                </div>
                                <div class="bg-dark-800 rounded-lg p-3 text-center">
                                    <div class="text-2xl font-bold text-purple-400" x-text="(metricsData?.process?.memory_rss_mb || 0).toFixed(0) + ' MB'"></div>
                                    <div class="text-xs text-dark-500">Memory</div>
                                </div>
                                <div class="bg-dark-800 rounded-lg p-3 text-center">
                                    <div class="text-2xl font-bold text-green-400" x-text="metricsData?.process?.threads || 0"></div>
                                    <div class="text-xs text-dark-500">Threads</div>
                                </div>
                            </div>
                        </div>
                        <!-- System Metrics -->
                        <div>
                            <h4 class="text-sm font-medium text-dark-400 mb-3">System</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div class="bg-dark-800 rounded-lg p-3">
                                    <div class="flex justify-between items-center mb-2">
                                        <span class="text-dark-400">CPU</span>
                                        <span class="text-white" x-text="(metricsData?.system?.cpu_percent || 0).toFixed(1) + '%'"></span>
                                    </div>
                                    <div class="bg-dark-700 rounded-full h-2">
                                        <div class="bg-blue-500 h-2 rounded-full transition-all" :style="'width: ' + (metricsData?.system?.cpu_percent || 0) + '%'"></div>
                                    </div>
                                </div>
                                <div class="bg-dark-800 rounded-lg p-3">
                                    <div class="flex justify-between items-center mb-2">
                                        <span class="text-dark-400">Memory</span>
                                        <span class="text-white" x-text="(metricsData?.system?.memory_percent || 0).toFixed(1) + '%'"></span>
                                    </div>
                                    <div class="bg-dark-700 rounded-full h-2">
                                        <div class="bg-purple-500 h-2 rounded-full transition-all" :style="'width: ' + (metricsData?.system?.memory_percent || 0) + '%'"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Disk Metrics -->
                        <div>
                            <h4 class="text-sm font-medium text-dark-400 mb-3">Disk (Work Directory)</h4>
                            <div class="bg-dark-800 rounded-lg p-3">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="text-dark-400">Used</span>
                                    <span class="text-white" x-text="(metricsData?.disk?.used_gb || 0).toFixed(1) + ' / ' + (metricsData?.disk?.total_gb || 0).toFixed(1) + ' GB'"></span>
                                </div>
                                <div class="bg-dark-700 rounded-full h-2">
                                    <div class="bg-yellow-500 h-2 rounded-full transition-all" :style="'width: ' + (metricsData?.disk?.percent || 0) + '%'"></div>
                                </div>
                            </div>
                        </div>
                        <!-- GPU Metrics (if available) -->
                        <template x-if="metricsData?.gpu">
                            <div>
                                <h4 class="text-sm font-medium text-dark-400 mb-3">GPU</h4>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-dark-800 rounded-lg p-3">
                                        <div class="flex justify-between items-center mb-2">
                                            <span class="text-dark-400">GPU Utilization</span>
                                            <span class="text-white" x-text="(metricsData?.gpu?.utilization_percent || 0).toFixed(0) + '%'"></span>
                                        </div>
                                        <div class="bg-dark-700 rounded-full h-2">
                                            <div class="bg-green-500 h-2 rounded-full transition-all" :style="'width: ' + (metricsData?.gpu?.utilization_percent || 0) + '%'"></div>
                                        </div>
                                    </div>
                                    <div class="bg-dark-800 rounded-lg p-3">
                                        <div class="flex justify-between items-center mb-2">
                                            <span class="text-dark-400">VRAM</span>
                                            <span class="text-white" x-text="(metricsData?.gpu?.memory_used_mb || 0).toFixed(0) + ' / ' + (metricsData?.gpu?.memory_total_mb || 0).toFixed(0) + ' MB'"></span>
                                        </div>
                                        <div class="bg-dark-700 rounded-full h-2">
                                            <div class="bg-cyan-500 h-2 rounded-full transition-all" :style="'width: ' + (metricsData?.gpu?.memory_utilization_percent || 0) + '%'"></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="mt-2 text-sm text-dark-500 text-center" x-text="'Temperature: ' + (metricsData?.gpu?.temperature_c || 0) + '\u00B0C'"></div>
                            </div>
                        </template>
                    </div>
                </template>
            </div>
        </div>
    </div>
</body>
</html>
